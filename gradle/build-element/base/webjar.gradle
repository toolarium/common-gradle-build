/*
 * webjar.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * 
 * This file is part of the toolarium common-gradle-build.
 * 
 * The common-gradle-build is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The common-gradle-build is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar. If not, see <http://www.gnu.org/licenses/>.
 */


/***************************************************************************************
 * far webJar support
 ***************************************************************************************/
configurations {
	webJar
/*  
		withDependencies { DependencySet dependencies ->
			printInfo dependencies
		}
*/		
}
configurations.webJar {
	transitive = false

	attributes {
		attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_API))
	}
}


/****************************************************************************************
 * Build fat webJar, usage examples:
 * def changedFiles = replaceFilesInPathWithSlahes("/deployment/myapp", ".js", "administration/", "new-admin/")
 * def changedFiles = replaceFilesInPathWithSlahes("/deployment/myapp", ".json", "administration/", "new-admin/")
 * def changedFiles = replaceFilesInPathWithSlahes("/deployment/myapp", null, "administration/", "new-admin/")  // All files
 ***************************************************************************************/
import java.nio.file.*
import java.nio.file.attribute.BasicFileAttributes
import java.util.regex.Pattern
import java.nio.charset.StandardCharsets
ext.replaceFilesInPathWithSlahes = { filePath, fileExtension, sourcePattern, replacement ->
    def changedFiles = []
    
    // Helper function to detect binary files
    def isBinaryFile = { Path file ->
        try {
            // Read first 1024 bytes to check for binary content
            def bytes = Files.readAllBytes(file)
            if (bytes.length == 0) return false
            
            def sampleSize = Math.min(1024, bytes.length)
            def nullBytes = 0
            for (int i = 0; i < sampleSize; i++) {
                if (bytes[i] == 0) nullBytes++
            }
            // If more than 1% null bytes, consider it binary
            return (nullBytes / sampleSize) > 0.01
        } catch (Exception e) {
            return true // If we can't read it, treat as binary
        }
    }
    
    // Create all the patterns we need to handle different encodings
    def createReplacementPatterns = { String source, String target ->
        def sourceEscaped = Pattern.quote(source)
        def sourceWithoutSlash = source.endsWith('/') ? source.substring(0, source.length() - 1) : source
        def sourceWithoutSlashEscaped = Pattern.quote(sourceWithoutSlash)
        
        // Normalize target - remove any trailing slashes for consistent handling
        def normalizedTarget = target.replaceAll('/$', '')
        return [
            // 1. standard replacement (use normalized target)
            [Pattern.compile(sourceEscaped), normalizedTarget],
            
            // 2. unicode escape sequences (\u002F for /) - the \u002F IS the slash, so replace with target + /
            [Pattern.compile(sourceEscaped + "\\\\\\\\u002[Ff]"), normalizedTarget + "/"],
            [Pattern.compile(sourceWithoutSlashEscaped + "\\\\\\\\u002[Ff]"), normalizedTarget + "/"],
            
            // 3. URL encoding (%2F for /) - the %2F IS the slash, so replace with target + /
            [Pattern.compile(sourceEscaped + "%2[Ff]"), normalizedTarget + "/"],
            [Pattern.compile(sourceWithoutSlashEscaped + "%2[Ff]"), normalizedTarget + "/"],
            
            // 4. JSON/JavaScript escaped slashes (\/) - the \/ IS the slash, so replace with target + /
            [Pattern.compile(sourceEscaped + "\\\\\\\\/"), normalizedTarget + "/"],
            [Pattern.compile(sourceWithoutSlashEscaped + "\\\\\\\\/"), normalizedTarget + "/"],
            
            // 5. double escaped slashes (\\/) - the \\/ IS the slash, so replace with target + /
            [Pattern.compile(sourceEscaped + "\\\\\\\\\\\\\\\\/"), normalizedTarget + "/"],
            [Pattern.compile(sourceWithoutSlashEscaped + "\\\\\\\\\\\\\\\\/"), normalizedTarget + "/"],

            // 6. quoted contexts with different quote types (use original target)
            [Pattern.compile("\"" + sourceEscaped + "\""), "\"" + target + "\""],
            [Pattern.compile("'" + sourceEscaped + "'"), "'" + target + "'"],
            [Pattern.compile("`" + sourceEscaped + "`"), "`" + target + "`"]
        ]
    }
    
    def replacementPatterns = createReplacementPatterns(sourcePattern, replacement)
    
    Files.walkFileTree(new File(filePath.toString()).toPath(), new SimpleFileVisitor<Path>() {
        @Override
        FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
            if (Files.isRegularFile(file) && 
                (fileExtension == null || fileExtension.isEmpty() || file.getFileName().toString().endsWith(fileExtension))) {
                
                // Skip binary files
                if (isBinaryFile(file)) {
                    return FileVisitResult.CONTINUE
                }
                
                try {
                    def content = new String(Files.readAllBytes(file), StandardCharsets.UTF_8)
                    def originalContent = content
                    def wasModified = false
                    
                    // Protect API paths first (equivalent to shell script's API protection)
                    def apiProtectionPattern = Pattern.compile("api/" + Pattern.quote(sourcePattern))
                    content = apiProtectionPattern.matcher(content).replaceAll("__PROTECTED_API__")
                    
                    // Apply all replacement patterns
                    replacementPatterns.each { patternInfo ->
                        def pattern = patternInfo[0]
                        def targetReplacement = patternInfo[1]
                        def newContent = pattern.matcher(content).replaceAll(targetReplacement)
                        if (!content.equals(newContent)) {
                            content = newContent
                            wasModified = true
                        }
                    }
                    
                    // Restore protected API paths
                    def restoreApiPattern = Pattern.compile("__PROTECTED_API__")
                    content = restoreApiPattern.matcher(content).replaceAll("api/" + sourcePattern)
                    
                    // Write back if content changed
                    if (wasModified || !originalContent.equals(content)) {
                        Files.write(file, content.getBytes(StandardCharsets.UTF_8))
                        changedFiles.add(file.toFile())
                    }
                    
                } catch (Exception e) {
                    printWarn("Could not process file [" + colorize(HIGHLITE_LEVEL, file) + colorize(WARN_LEVEL, "]: " +e.getMessage())) 
                }
            }
            return FileVisitResult.CONTINUE
        }
        
        @Override
        FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
            printWarn("Failed to visit file [" + colorize(HIGHLITE_LEVEL, file) + colorize(WARN_LEVEL, "]: " +exc.getMessage())) 
            return FileVisitResult.CONTINUE
        }
    })
    
    return changedFiles
}


/****************************************************************************************
 * Build fat webJar
 ****************************************************************************************/
task buildFatWebJar {  ->
	onlyIf { return validBuild }

	doLast {
		def fatWebClassifierContext = ""
		if (project.hasProperty("fatWebClassifierContext") && !project.getProperty("fatWebClassifierContext").toString().isEmpty()) {
			fatWebClassifierContext = "-" + project.getProperty("fatWebClassifierContext")
		}

		def fatWebSubContext = ""
		if (project.hasProperty("fatWebSubContext") && !project.getProperty("fatWebSubContext").toString().isEmpty()) {
			fatWebSubContext = project.getProperty("fatWebSubContext")
		}

		def fatWebJarPathName = "web"
		if (project.hasProperty("fatWebJarPathName") && !project.getProperty("fatWebJarPathName").toString().isEmpty()) {
			fatWebJarPathName = project.getProperty("fatWebJarPathName")
		}

        def fatWebFilename = "${gradleBuildDirectory}/libs/${project.name}-${project.version}${fatWebClassifierContext}.jar"
		if (project.hasProperty('createFatJar') && project.getProperty('createFatJar').toString().trim().equalsIgnoreCase("true")) {
			printInfo("> Create web fat-jar " + colorize(HIGHLITE_LEVEL, "${fatWebFilename}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
			def distWebPath = "${gradleBuildDirectory}/$fatWebJarPathName"
            mkdir "$distWebPath"
            mkdir "$distWebPath/${commonGradleBuildDistName}"

            def sourceFilename = "";
			def sourceJarFilePath = "${gradleBuildDirectory}/libs";
            configurations.webJar.collect {
                if (it.getName().toString().startsWith("${webServerRunnerName}".toString())) {
                    printInfo("  -> Use lib dependency " + colorize(HIGHLITE_LEVEL, it.getName()) + "...")
                    copyFile(""+it, "$sourceJarFilePath/" + it.getName().toString(), true)
                    sourceFilename = it.getName().toString()
                }
            }

			def sourceJarFile = "$sourceJarFilePath/${sourceFilename}";
			if (sourceFilename!=null && new File(sourceJarFile).exists()) {
				if (new File("${commonGradleBuildDistPath}").exists()) {
					if (!"${fatWebSubContext}".toString().isBlank()) {
						mkdir "$distWebPath/${commonGradleBuildDistName}/${fatWebSubContext}"
						copy { from "${commonGradleBuildDistPath}" into "${distWebPath}/${commonGradleBuildDistName}/${fatWebSubContext}" }
					} else {
						copy { from "${commonGradleBuildDistPath}" into "${distWebPath}/${commonGradleBuildDistName}" }
					}
				}
				
				if (!trimSlahes("${dockerSubPathAccess}").toString().trim().equals(trimSlahes("${fatWebSubContext}").toString().trim())) {
					// e.g.fatWebSubContext=/my/app/my-ui, dockerSubPathAccess=my/other/app/my-ui/
					def fatWebSubContextReplqacement=trimSlahes("${fatWebSubContext}").toString().trim() + "/"
					printInfo("> Apply source files path from " + colorize(HIGHLITE_LEVEL, dockerSubPathAccess) + " -> " + colorize(HIGHLITE_LEVEL, fatWebSubContextReplqacement) + " (in " + colorize(HIGHLITE_LEVEL, "${distWebPath}/${commonGradleBuildDistName}/") + ")...")

					def filesReplaced = []
					if ("$fatWebSubContextReplqacement".toString().equals("/")) {
						filesReplaced += replaceFilesInPathWithSlahes("${project.rootDir}".replace('\\', '/') + "/${distWebPath}/${commonGradleBuildDistName}/".toString(), null, "/" + trimSlahes("${dockerSubPathAccess}").toString().trim(), "$fatWebSubContextReplqacement")
						//filesReplaced += replaceFilesInPath("${project.rootDir}".replace('\\', '/') + "/${distWebPath}/${commonGradleBuildDistName}/".toString(), null, "/${dockerSubPathAccess}", "$fatWebSubContextReplqacement")
					} else {
						filesReplaced += replaceFilesInPathWithSlahes("${project.rootDir}".replace('\\', '/') + "/${distWebPath}/${commonGradleBuildDistName}/".toString(), null, trimSlahes("${dockerSubPathAccess}").toString().trim(), "$fatWebSubContextReplqacement")
					}
					logInfo("  -> Updated files " + colorize(HIGHLITE_LEVEL, "" + filesReplaced) + colorize(INFO_LEVEL, "."))
					printInfo("  -> Updated " + colorize(HIGHLITE_LEVEL, "" + filesReplaced.size()) + " file(s).")
					buildServiceProperties("${distWebPath}", "${servicePropertiesName}", "${fatWebSubContext}", "${gradlePropertiesFile}", "fatWebSubContext"); 
					
					setCommonGradleProperty("dockerSubPathAccessBackup", "$dockerSubPathAccess") // backup
					setCommonGradleProperty("dockerSubPathAccess", "$fatWebSubContext") // overwrite dockerSubPathAccess temporary
					createFileFromTemplate("${distWebPath}/${webServerRunnerPropertiesName}", getTemplateFile("${webServerRunnerPropertiesName}.template", 'base'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
					setCommonGradleProperty("dockerSubPathAccess", "$dockerSubPathAccessBackup") // restore
				} else {
					buildServiceProperties("${distWebPath}", "${servicePropertiesName}", "${fatWebSubContext}", "${gradlePropertiesFile}", "dockerSubPathAccess"); 
					createFileFromTemplate("${distWebPath}/${webServerRunnerPropertiesName}", getTemplateFile("${webServerRunnerPropertiesName}.template", 'base'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
				}
				
				buildFatJar("${distWebPath}", "${sourceJarFile}", "${fatWebFilename}", true)
			}
        } else {
			if (new File(fatWebFilename).exists()) {
				delete fatWebFilename
			}
        }
    }
}


if (!project.getProperty('IS_NEW')) {
	if (project.hasProperty('createFatJar') && project.getProperty('createFatJar').toString().trim().equalsIgnoreCase("true")) {
		logInfo("Enable build webserver fat jar.")
		
		dependencies {
			webJar "${webServerRunnerPackage}:${webServerRunnerName}:${webServerRunnerVersion}"
		}
	}
}
