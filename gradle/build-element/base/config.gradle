/*
 * config.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * MIT License: https://mit-license.org
 */


def configPackages = project.getProperty("configPackages").split(",")
def configDirectory = project.getProperty("configDirectory")
if (configDirectory!=null && !configDirectory.isEmpty()) {
    if (configDirectory.startsWith("./")) {
        configDirectory = configDirectory.substring(2)
    }
}


/***************************************************************************************
 * config jar task
 ***************************************************************************************/
task configJar(type: Jar) { jar ->
	group = 'Build'
	description = 'Assembles the configuration into a jar file(s) depend on configPackages entries (default only one package)'
	
	if (project.hasProperty('configPackageArchiveClassifier')) {
		archiveClassifier = project.getProperty('configPackageArchiveClassifier')
	}

	into "${configDirectory}", {
		from "${configDirectory}"
	}

	// include readme, license and version files
	into 'META-INF', {
		if (project.getProperty('includeReadmeFile')) {
			from "${readmeFile}"
		}

		if (project.getProperty('includeLicenseFile')) {
			from "${licenseFile}"
		}

		if (project.getProperty('includeVersionFile')) {
			from "${versionFile}"
		}

		if (project.getProperty('includeChangelogFile')) {
			from "${changelogFile}"
		}
	}

	// define proper manifest
	manifest {
		attributes 	'Specification-Title'   : rootProject.name,
					'Specification-Version' : project.version,
					'Implementation-Title'  : rootProject.name,
					'Implementation-Version': project.version + project.ext.scmVersionNumber,
					'Created-By'		   	: project.ext.buildToolVersionStackMessage,
					'Built-By'			   	: project.ext.publishingUsername,
					'Build-Timestamp'	   	: BUILD_TIMESTAMP,
					'Build-JDK'			   	: "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
					'Build-OS'			   	: "${System.properties['os.name']} (${System.properties['os.version']}), ${System.properties['os.arch']}"
	}

	doLast {
		if (project.hasProperty('showCreatedArtefacts') && project.getProperty('showCreatedArtefacts')) {
			// jar.archiveFileName
			def filename = prepareFilename(jar.archivePath.getPath())
			printInfo("> Created package " + colorize(HIGHLITE_LEVEL, filename) + ".")
		}
	}
}

configPackages.each { configName ->
	def configTypeProperty = configName.trim()

	if (configTypeProperty != null && !configTypeProperty.isEmpty()) {

		def configDirectoryPath = "${configDirectory}/${configTypeProperty}"
		def configFileExist = new File(configDirectoryPath).exists()
		if (!configFileExist) {
			configFileExist = new File(configDirectoryPath).mkdirs()
		}
		
		if (!project.getProperty("configIgnoreEmptyPackages") || configFileExist) {

			def taskName = "configJar${configTypeProperty}"
			tasks.create(name: taskName, type: Jar) { jar ->
				def prefix = ''
				if (project.hasProperty('configPackageArchiveClassifier') && !project.getProperty('configPackageArchiveClassifier').toString().trim().isEmpty()) {
					prefix = project.getProperty('configPackageArchiveClassifier') + '-'
				}

				archiveClassifier = prefix + configTypeProperty
				def configIncludeFilter = '**'
				logInfo("Add task $name: [" + colorize(HIGHLITE_LEVEL, configDirectoryPath) + colorize(INFO_LEVEL, "], filter: [") + colorize(HIGHLITE_LEVEL, configIncludeFilter) + colorize(INFO_LEVEL, "]"))

				into "${configDirectory}", {
					from "${configDirectoryPath}", {
						include "${configIncludeFilter}"
					}
				}

				// include readme, license and version files
				into 'META-INF', {
					if (project.getProperty('includeReadmeFile')) {
						from "${readmeFile}"
					}

					if (project.getProperty('includeLicenseFile')) {
						from "${licenseFile}"
					}

					if (project.getProperty('includeVersionFile')) {
						from "${versionFile}"
					}
				}

				// define proper manifest
				manifest {
					attributes 	'Specification-Title'   : rootProject.name,
								'Specification-Version' : project.version,
								'Implementation-Title'  : rootProject.name + "#" + configTypeProperty,
								'Implementation-Version': project.version + project.ext.scmVersionNumber,
								'Created-By'		   	: project.ext.buildToolVersionStackMessage,
								'Built-By'			   	: project.ext.publishingUsername,
								'Build-Timestamp'	   	: BUILD_TIMESTAMP,
								'Build-JDK'			   	: "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
								'Build-OS'			   	: "${System.properties['os.name']} (${System.properties['os.version']}), ${System.properties['os.arch']}"
				}

				doLast {
					if (project.hasProperty('showCreatedArtefacts') && project.getProperty('showCreatedArtefacts')) {
						// jar.archiveFileName
						def filename = prepareFilename(jar.archivePath.getPath())
						printInfo("> Created package " + colorize(HIGHLITE_LEVEL, filename) + ".")
					}
				}
			}

			configJar.dependsOn taskName
		} else if (!configFileExist) {
			printWarn("Directory " + colorize(HIGHLITE_LEVEL, configDirectoryPath) + colorize(WARN_LEVEL, " is not available!"))
		}
	}
}
