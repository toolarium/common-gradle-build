/*
 * util.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * MIT License: https://mit-license.org
 */


/** 
 * Encode base64
 */
ext.encodeBase64 = { data, propertyCheckName = "" ->
	if (!project.hasProperty(propertyCheckName) || project.getProperty(propertyCheckName)) {
		return data.bytes.encodeBase64().toString()
	}
	
	return data
}


/** 
 * Decode base64
 */
ext.decodeBase64 = { encodedData, propertyCheckName = "" ->
	if (!project.hasProperty(propertyCheckName) || project.getProperty(propertyCheckName)) {
		return new String(encodedData.decodeBase64())
	}
	
	return encodedData
}


/** 
 * Add an error
 */
ext.addError = { message ->
	ext.validBuild=false
	ext.errorMessagePrefix=""
	
	if (message!=null && !message.isEmpty()) {
		if (!ext.validBuildMessage.toString().trim().isEmpty()) {
			ext.validBuildMessage+="\n"
		}
		
		ext.validBuildMessage+="  - ${message}\n"
	}
}


/** 
 * Read os specific configuration: osEnvironment, separator, scriptEnding
 */
ext.readOSConfiguration = { ->
    if (!project.hasProperty('separator') || !project.hasProperty('scriptEnding') || !project.hasProperty('osEnvironment')) {
        def osEnvironment=getOsName()
        def separator='/'
        def scriptEnding='.sh'

        if (osEnvironment.toLowerCase().startsWith("windows")) {
            def sout = new StringBuilder(), serr = new StringBuilder()
			separator='\\'
			scriptEnding='.bat'
			
			try {
				execRawCommand([ 'uname' ], 2000, sout, serr)
				if (sout.toString().toLowerCase().startsWith('cygwin')) {
					osEnvironment="cygwin"
					scriptEnding='.bat'
				}
			} catch(Exception ex) {
				logDebug("Not cygwin environment.")
			}
        }

        setCommonGradleProperty('separator', separator)
        setCommonGradleProperty('scriptEnding', scriptEnding)
        setCommonGradleProperty('osEnvironment', osEnvironment)
    }
}


/** 
 * Get the arch type
 */
ext.parseInteger = { value, defaultValue = 0, type = "" ->
	if (value == null) {
		return defaultValue;
	} else if (value instanceof Integer) {
		return value
	} else {
		try {
			return Integer.parseInt(("" + value).trim());
		} catch (Exception e) {
			if (type != null || type.isEmpty()) {
				printWarn("Could not parse value of ${type}, it's not an integer [${value}]: " + e.getMessage())
			} else {
				printWarn("Could not parse value, it's not an integer [${value}]: " + e.getMessage())
			}
			return defaultValue;
		}
	}
}


/** 
 * Get the arch type
 */
import org.gradle.api.JavaVersion;
ext.parseVersion = { version ->
	if (version == null) {
		return null;
	} 
	
	try {
		return JavaVersion.toVersion(version)
		
		def input = version.toString().trim()
		if (!input.startsWith("VERSION")) {
			input = "VERSION_" + input.replace('.', '_')
		}
		
		//return JavaVersion.toVersion(input)
	} catch (IllegalArgumentException e) {
		printInfo("> Error in parseVersion: " + e.getMessage())
	}
}


/** 
 * Get the hostname
 */
ext.JAVA_LANG_PROCESS_HANDLE = "java.lang.ProcessHandle";
ext.getProcessNumber = { ->
	def processNumber = ""	
	try {
		try {
			Class clazz = Class.forName(JAVA_LANG_PROCESS_HANDLE)
			
			try {
				java.lang.reflect.Method method = clazz.getMethod("current", null)
				processNumber = "" + method.invoke(null, null)
				return processNumber
			} catch(Exception e) {
			}			
		} catch (Exception e) {
		}
	} catch (Exception e) {
	}
	
	if (java.lang.management.ManagementFactory.getRuntimeMXBean() != null) {
		try {
			String processName = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
			if (processName != null && processName.length() > 0) {
				try  {
					processNumber = processName.split("@")[0]
					return processNumber					
				} catch(Exception e) {
				}
			}
		
			java.lang.management.RuntimeMXBean runtime = java.lang.management.ManagementFactory.getRuntimeMXBean();
			java.lang.reflect.Field jvm = runtime.getClass().getDeclaredField("jvm")
				
			if (jvm!=null)  {
				jvm.setAccessible(true);
				sun.management.VMManagement mgmt = (sun.management.VMManagement)jvm.get(runtime);
				java.lang.reflect.Method pidMethod = mgmt.getClass().getDeclaredMethod("getProcessId");
				pidMethod.setAccessible(true)
				processNumber = pidMethod.invoke(mgmt)
				return processNumber
			}
		} catch (Exception e) {
		}
	}
		
	return processNumber
}

 
/** 
 * Get the hostname
 */
ext.getHostName = { ->
	String hostname;
	
	// get hostname
	hostname = System.env['hostname']
	if (hostname==null || hostname.isEmpty()) {
		hostname = System.env['HOSTNAME']
		if (hostname==null || hostname.isEmpty())
			hostname = System.env['COMPUTERNAME']
	}
	
	if (hostname==null || hostname.isEmpty())
		hostname = "localhost";
		
	return hostname;
}
 

/** 
 * Get the os name
 */
ext.getOsName = { ->
	final String osName = System.getProperty("os.name").toLowerCase();

	if (osName.contains("linux")) {
		return ("linux");
	} else if (osName.contains("mac os x") || osName.contains("darwin") || osName.contains("osx")) {
		return ("macos");
	} else if (osName.contains("windows")) {
		return ("windows");
	} else if (osName.contains("sunos") || osName.contains("solaris")) {
		return ("solaris");
	} else if (osName.contains("freebsd")) {
		return ("freebsd");
	}
	return ("unix");
}


/** 
 * Get the arch type
 */
ext.getOsArch = { ->
	final String osArch = System.getProperty("os.arch");

	if ("x86".equals(osArch)) {
		return ("i386");
	}
	else if ("x86_64".equals(osArch)) {
		return ("amd64");
	}
	else if ("powerpc".equals(osArch)) {
		return ("ppc");
	}
	return (osArch);
}


/** 
 * Check is JDK is unlimited juristisction
 */
ext.isUnlimitedJurisdiction = { ->
	def DEFAULT_CIPHER_NAME = "AESa"
	def UNLIMITED_JURISDICTION_KEY_SIZE = 1024
	
	try
	{
		javax.crypto.Cipher.getInstance(DEFAULT_CIPHER_NAME);
		if (javax.crypto.Cipher.getMaxAllowedKeyLength(DEFAULT_CIPHER_NAME) > UNLIMITED_JURISDICTION_KEY_SIZE) {
			return true;
		}
	} catch (java.security.NoSuchAlgorithmException noe) {
		return true
	} catch( Exception e ) {
	}

	return false;
}


/** 
 * Check if remote resource is available
 */
ext.isServerAvailable = { serverAddress='www.google.com', timeout=1500 ->
	try {
		if (!gradle.startParameter.isOffline()) {
			return java.net.InetAddress.getByName(serverAddress).isReachable(timeout)
		} 
	} catch( Exception e ) {
	}

	return false;
}


/** 
 * Prepare relative path
 */
ext.prepareFilename = { file ->
	def filename = file.trim().replace('\\', '/')
	if (filename.startsWith(cbProjectRootDir)) {
		filename = filename.substring(cbProjectRootDir.length() + 1)
	}
	
	return filename
}


/** 
 * Unzip zip file
 */
ext.unzip = { fileZip, inputDestDir, rootZipFolderName = null ->
	File rootFolder = null;
	long countEntries = 0;
	java.util.zip.ZipInputStream zis = new java.util.zip.ZipInputStream(new java.io.FileInputStream(fileZip));
	try {
		java.util.zip.ZipEntry zipEntry = zis.getNextEntry();
		while (zipEntry != null) {
			String filename = (inputDestDir + "/" + zipEntry.getName()).replace('\\', '/');
			String path = "";
			int idx = filename.lastIndexOf('/');
			if (idx>0) {
				path = filename.substring(0, idx);
				filename = filename.substring(idx+1);
			}
			
			java.io.File file = new java.io.File(path + "/" + filename);
			(new java.io.File(path)).mkdirs();
			if (!zipEntry.isDirectory()) {
				java.io.FileOutputStream fos = new java.io.FileOutputStream(file);
				byte[] buffer = new byte[1024]; int len;
				while ((len = zis.read(buffer)) > 0) {
					fos.write(buffer, 0, len);
				}
				fos.close();
			} else {
				if (countEntries == 0) {
					rootFolder = file;
				}
			}
			
			file.setLastModified(zipEntry.getTime());
			zipEntry = zis.getNextEntry();
			countEntries++;
		}
				
		if (rootZipFolderName!=null && !rootZipFolderName.isEmpty()) {
			if (rootFolder!=null) {
				rootFolder.renameTo(new java.io.File(inputDestDir, rootZipFolderName))
			} else {
				printInfo("> Could not rename root folder to [" + colorize(HIGHLITE_LEVEL, rootZipFolderName) + colorize(WARN_LEVEL, "] because there is no root folder in zip file.")) 
			}
		}
	} finally {
		zis.closeEntry();
		zis.close();
	}
}


/** 
 * Copy and hash task
 */
 /*
task copyAndHash(type: Copy) {
  MessageDigest sha1 = MessageDigest.getInstance("SHA-1");

  into 'build/deploy'
  from 'source'
  eachFile { fileCopyDetails ->
    sha1.digest(fileCopyDetails.file.bytes)
  }
  doLast {
    Formatter hexHash = new Formatter()
    sha1.digest().each { b -> hexHash.format('%02x', b) }
    println hexHash
  }
}*/