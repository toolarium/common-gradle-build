/*
 * docker.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * 
 * This file is part of the toolarium common-gradle-build.
 * 
 * The common-gradle-build is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The common-gradle-build is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar. If not, see <http://www.gnu.org/licenses/>.
 */


/***************************************************************************************
 * Check if docker installation is ready to use
 ***************************************************************************************/
//setCommonGradleDefaultPropertyIfNull("dockerFileTemplateName", "Dockerfile-node.properties.template")
setCommonGradleDefaultPropertyIfNull("dockerFileTemplateName", "Dockerfile.properties.template")
setCommonGradleDefaultPropertyIfNull("IS_NEW_SRC_FOLDER", false)
setCommonGradleDefaultPropertyIfNull("createApplicationConfigFile", false)

ext.dockerInstallationValidated=false
ext.dockerInstallationCommandAvailable=false
ext.dockerInstallationAvailable=false
ext.checkDockerInstallation = { ->
	if (!dockerInstallationValidated) {
		dockerInstallationValidated=true
		def stdout = new StringBuilder()
		def exitStatus = execCommand("docker --version", -1, stdout, stdout)
		dockerInstallationCommandAvailable=(exitStatus==0)
		
		if (dockerInstallationCommandAvailable) {
			logInfo("Docker installation is available.")
			
			exitStatus = execCommand("docker info")
			dockerInstallationAvailable=(exitStatus==0)

			if (dockerInstallationAvailable) {
				logInfo("Docker installation is ready.")
			} else {
				setCommonGradleProperty("errorMessagePrefix", "")
				addError("Docker installation is not ready.")
			}
		} else {
			setCommonGradleProperty("errorMessagePrefix", "")
			addError("Missing docker installation.")
		}
	}
	
	return dockerInstallationAvailable
} 


/***************************************************************************************
 * Execute docker command
 ***************************************************************************************/
ext.execDocker = { cmd, errorMessage, failOnError = true ->
	def sout = new StringBuilder(), serr = new StringBuilder()				
	def exitStatus = execCommand(cmd, -1, sout, serr)
	if (exitStatus>0) {
		if (failOnError) {
			addError("$errorMessage")
			if (sout!=null && !sout.toString().isEmpty()) {
				addError(sout.toString())
			}
			if (serr!=null && !serr.toString().isEmpty()) {
				addError(serr.toString())
			}
			
			throw new GradleException(errorMessage)		
		} else {
			printWarn("$errorMessage")
		}
	}
	
	return exitStatus
}


/***************************************************************************************
 * docker build task
 ***************************************************************************************/
task dockerBuild {
	group = 'Build'
	description = 'Create a docker image.'

	doLast {
		if (!project.getProperty('IS_NEW') && checkDockerInstallation()) {
			def dockerSourceMessage="project"
			def deleteDockerIgnoreFile=false
			def localDockerFileExist=new File("$dockerFile").exists()
			def localDockerTemplateFileExist=new File("$dockerFileTemplate").exists()
			def localFileExist=(localDockerFileExist || localDockerTemplateFileExist)
			def supportProjectDockerfile=project.hasProperty("projectIndividualDockerfie") && project.getProperty("projectIndividualDockerfie")
			def createProjectDockerfile=project.hasProperty("createProjectIndividualDockerfie") && project.getProperty("createProjectIndividualDockerfie")
			def tempDockerFile=getUniqueTempName("${rootProject.name}", "${project.version}-dockerfile", null)

			if (project.hasProperty('dockerSupportProjectTemplateList') && project.getProperty('dockerSupportProjectTemplateList') && project.hasProperty('allowedDockerfileTemplateProjects')) {
				def allowedDockerfileTemplateProjectList = new ArrayList(Arrays.asList(allowedDockerfileTemplateProjects.split(", ")))
				if (allowedDockerfileTemplateProjectList!=null && !allowedDockerfileTemplateProjectList.isEmpty() && !allowedDockerfileTemplateProjectList.contains("${rootProject.name}".toString())) {
					supportProjectDockerfile = false
					createProjectDockerfile = false
					
					if (localFileExist) {
						def ignoreDockerFilename = "$dockerFileTemplate"
						if (localDockerFileExist) {
							ignoreDockerFilename = "$dockerFile"
						}
						
						printWarn("This project is not allowed to have own file " +colorize(HIGHLITE_LEVEL, ignoreDockerFilename) + "!")
						if ("true".equalsIgnoreCase("" + project.getProperty('isReleaseVersion'))) {
							addError("Found not supported dockerfile ${ignoreDockerFilename}!")
						}
					}
				}
			}
	
			if (supportProjectDockerfile && createProjectDockerfile) {			
				if (!localFileExist) {
					// create local file in project 
					createFileFromTemplate("$dockerFileTemplate", getTemplateFile("$dockerFileTemplateName"), true, true, false /* keep template*/)
					
					if (project.hasProperty('dockerIgnoreFilename') && !project.getProperty('dockerIgnoreFilename').toString().isEmpty()) {
						createFileFromTemplate("$dockerIgnoreFile", getTemplateFile('dockerignore.template'))
					}
					
					// create from local file
					localDockerTemplateFileExist = createFileFromTemplate("$tempDockerFile", "$dockerFileTemplate")
					localFileExist=(localDockerFileExist || localDockerTemplateFileExist)
				}

				if (localDockerFileExist) {
					// create from local file
					printInfo("> Prepare dockerfile from " +colorize(HIGHLITE_LEVEL,  dockerFile) + " (new).")
					dockerSourceMessage="project"
					copyFile("$dockerFile", "$tempDockerFile")
				} else {
					printInfo("> Prepare dockerfile from template " +colorize(HIGHLITE_LEVEL,  dockerFileTemplate) + " (new).")
					dockerSourceMessage="project template"
					// create from local file
					createFileFromTemplatePath(tempDockerFile, getFilePath(dockerFileTemplate), "", getFilename(dockerFileTemplate), true, false)
				}
			} else if (supportProjectDockerfile && localFileExist) {
				if (localDockerFileExist) {
					// create from local file
					printInfo("> Prepare dockerfile from " +colorize(HIGHLITE_LEVEL,  dockerFile) + ".")
					dockerSourceMessage="project"
					copyFile("$dockerFile", "$tempDockerFile")
				} else {
					printInfo("> Prepare dockerfile from template " +colorize(HIGHLITE_LEVEL,  dockerFileTemplate) + ".")
					dockerSourceMessage="project template"
					createFileFromTemplatePath(tempDockerFile, getFilePath(dockerFileTemplate), "", getFilename(dockerFileTemplate), true, false)
				}

				if (!new File("$dockerIgnoreFile").exists() && !"$dockerIgnoreFile".toString().isEmpty()) {
					printInfo("> Create temporary " +colorize(HIGHLITE_LEVEL,  dockerIgnoreFile) + ".")
					deleteDockerIgnoreFile=true
					createFileFromTemplate("$dockerIgnoreFile", getTemplateFile('dockerignore.template'), false, false)
				}
			} else {
				printInfo("> Prepare dockerfile from template " +colorize(HIGHLITE_LEVEL, "/" + getTemplateFile("$dockerFileTemplateName")) + ".")
				dockerSourceMessage="global"
				createFileFromTemplate("$tempDockerFile", getTemplateFile("$dockerFileTemplateName"), true, false)

				if (!new File("$dockerIgnoreFile").exists() && !"$dockerIgnoreFile".toString().isEmpty()) {
					printInfo("> Create temporary " +colorize(HIGHLITE_LEVEL,  dockerIgnoreFile) + ".")
					deleteDockerIgnoreFile=true
					createFileFromTemplate("$dockerIgnoreFile", getTemplateFile('dockerignore.template'), false, false)
				}
			}
			
			def dockerBuildName="${rootProject.name}:${project.version}"
			logInfo("Use dockerfile [" +colorize(HIGHLITE_LEVEL, tempDockerFile) + colorize(INFO_LEVEL, "]."))
			if (project.hasProperty("dockerName") && !project.getProperty("dockerName").toString().isEmpty()) {
				dockerBuildName="$dockerName"
			}
			
			if (tempDockerFile.startsWith("./")) {
				tempDockerFile = cbProjectRootDir + "/" + tempDockerFile.substring(2)
			}
				
			printInfo("> Create docker image " + colorize(HIGHLITE_LEVEL,  dockerBuildName) + " (${dockerSourceMessage} dockerfile).")
			logInfo("Use dockerfile [" +colorize(HIGHLITE_LEVEL,  dockerBuildName) + colorize(INFO_LEVEL, "]."))
			
			def cmd="docker build -t ${dockerBuildName} ${dockerBuildPull} ${dockerBuildCompress}"
			if (!"${dockerBuildArgs}".toString().trim().isEmpty()) {
				cmd="$cmd ${dockerBuildArgs}"
			}
			cmd="$cmd -f ${tempDockerFile} $cbProjectRootDir"
			
			def exitStatus = execDocker(cmd, "Could not build docker image:\n    " + cmd)
			if (exitStatus==0) {
				if( project.hasProperty("dockerCleanupAfterBuild") && project.getProperty("dockerCleanupAfterBuild") ) {
					printInfo("> Remove docker image " +colorize(HIGHLITE_LEVEL, dockerBuildName) + ".")
					cmd="docker image remove $dockerBuildName"
					exitStatus = execDocker(cmd, "Could not remove project tag:\n    " + cmd, false)
				}
			}
			
			new File("$tempDockerFile").delete()
			if (deleteDockerIgnoreFile) {
				logInfo("Remove dockerignore " +colorize(HIGHLITE_LEVEL, dockerIgnoreFile) + ".")
				new File("$dockerIgnoreFile").delete()
			}

			def dockerRemoveImageIdList = []
			cmd="docker image ls ${rootProject.name}"
			def sout = new StringBuilder()
			exitStatus = execCommand(cmd, -1, sout, sout)
			if (exitStatus>0) {
				def message = "Could not read docker images:\n    " + colorize(HIGHLITE_LEVEL, cmd) + ":"
				if (sout!=null && !sout.toString().isEmpty()) {
					message = "${message}" + sout.toString()
				}
				logInfo(message)
			} else {
				try {
					def tagIndex, imageIndex, createdIndex, sizeIndex
					def readHeader = false
					sout.eachLine {line, count ->
						line = line.replace("IMAGE ID", "IMAGE_ID")
						
						def lineSplit = line.split(/\s+/)
						if (!readHeader) {
							for (int i = 0; i<lineSplit.length; i++) {
								if (lineSplit[i]!=null && !lineSplit[i].toString().isEmpty()) {
									if ("TAG".equals(lineSplit[i])) {
										tagIndex = i
									} else if ("IMAGE_ID".equals(lineSplit[i])) {
										imageIndex = i
									} else if ("CREATED".equals(lineSplit[i])) {
										createdIndex = i
									} else if ("SIZE".equals(lineSplit[i])) {
										sizeIndex = i
									}									
								}
							}
							readHeader = true
						} else {
							def sizeIdx = lineSplit.length -1
							if ("${project.version}".toString().equals(lineSplit[tagIndex])) {
								printInfo("> Docker images id " + colorize(HIGHLITE_LEVEL, lineSplit[imageIndex]) + ": " + colorize(HIGHLITE_LEVEL, lineSplit[sizeIdx]))
							} else {
							def duration = 1
								try {
									duration = Integer.valueOf(lineSplit[createdIndex])
								} catch(Exception e ) {
								}

								if (lineSplit[createdIndex+1].toString().startsWith("minute")) {
									duration = duration * 60
								} else if (lineSplit[createdIndex+1].toString().startsWith("hour")) {
									duration = duration * 60 * 60
								} else if (lineSplit[createdIndex+1].toString().startsWith("day")) {
									duration = duration * 60 * 60 * 24 
								} else if (lineSplit[createdIndex+1].toString().startsWith("week")) {
									duration = duration * 60 * 60 * 24 * 7
								} else if (lineSplit[createdIndex+1].toString().startsWith("month")) {
									duration = duration * 60 * 60 * 24 * 30
								} else if (lineSplit[createdIndex+1].toString().startsWith("year")) {
									duration = duration * 60 * 60 * 24 * 365
								}
							
								logInfo("Found different tag " + colorize(HIGHLITE_LEVEL, lineSplit[tagIndex]) 
										+ colorize(INFO_LEVEL,", docker images id ") + colorize(HIGHLITE_LEVEL, lineSplit[imageIndex]) + colorize(INFO_LEVEL, ": ") 
										+ colorize(HIGHLITE_LEVEL, lineSplit[sizeIdx]) + colorize(INFO_LEVEL, " (age ") + colorize(HIGHLITE_LEVEL, duration) + colorize(INFO_LEVEL, "s)"))
										
								if (!dockerRemoveImageIdList.contains(lineSplit[imageIndex])) {
									dockerRemoveImageIdList.add(lineSplit[imageIndex])
								}
							}
						}
					}	
				} catch (Exception e) {
					printWarn("Could not add artefact depdendency: " + e.getMessage())
					throw e
				}
			}

			if (project.hasProperty("dockerRemoveDanglingImages") && project.getProperty("dockerRemoveDanglingImages")) {
				printInfo("> Remove all dangling images...")
				sout = new StringBuilder()
				exitStatus = execCommand("docker images -f 'dangling=true' -q", -1, sout, null)
				if (exitStatus==0) {
					sout.eachLine {line, count ->
						logInfo("Remove dangling image ${line}...")
						cmd="docker rmi -f ${line}"
						execDocker(cmd, "Could not prune dangling image (${line}):\n    " + cmd, false)
					}
				}
			}
			
			if (project.hasProperty("dockerRemovePreviousVersionImages") && project.getProperty("dockerRemovePreviousVersionImages")) {
				def dockerMaxNumberOfImages = project.getProperty('dockerMaxNumberOfImages')
				def diff = dockerRemoveImageIdList.size() - dockerMaxNumberOfImages + 1
				if (diff>0) {
					def previousImageId = ""
					printInfo("> Remove $diff previous docker image(s) - max $dockerMaxNumberOfImages versions:")
					for (int i = 0; i<diff; i++) {
						def imageId = dockerRemoveImageIdList.removeLast()
						cmd="docker rmi -f $imageId"
						sout = new StringBuilder()
						exitStatus = execCommand(cmd, -1, sout, sout)
						if (exitStatus>0) {
							printInfo("  - Could not remove docker image " + colorize(HIGHLITE_LEVEL, imageId) + "!")
						} else {
							printInfo("  - Delete docker image " + colorize(HIGHLITE_LEVEL, imageId) + ".")
						}
					}
				}
			}
		}
	} 
}


/***************************************************************************************
 * docker build task
 ***************************************************************************************/
task dockerRun {
	group = 'Build'
	description = 'Run a docker image.'
    dependsOn dockerBuild 

	doLast {
		if (!project.getProperty('IS_NEW') && checkDockerInstallation()) {
			def dockerBuildName="${rootProject.name}:${project.version}"
			if( project.hasProperty("dockerName") && !project.getProperty("dockerName").toString().isEmpty() ) {
				dockerBuildName="$dockerName"
			}
			
			printInfo("> Run docker image " +colorize(HIGHLITE_LEVEL,  dockerBuildName) + ".")
			def cmd="docker run $dockerBuildName --rm".toString()
			printLine()
			def exitStatus = execDocker(cmd, "Could not run docker image:\n    " + cmd)
			logInfo("Ended with status code: " +colorize(HIGHLITE_LEVEL, exitStatus) + colorize(INFO_LEVEL, "."))
			printLine(HIGHLITE_LEVEL, true, " exit " + exitStatus + "")
		}
	} 
}


/***************************************************************************************
 * docker build task
 ***************************************************************************************/
task dockerPush {
	group = 'Build'
	description = 'Pusha docker image.'
    dependsOn dockerBuild 
	onlyIf { return project.hasProperty('validBuild') && project.getProperty('validBuild') }

	doLast {
		if (!project.getProperty('IS_NEW') && checkDockerInstallation()) {
			def dockerDeployRepositoryHost = ""
			def dockerTagPrefix = ""
			if (project.ext.isSnapshotVersion) {
				dockerDeployRepositoryHost=project.getProperty('dockerSnapshotRepositoryHost')
				dockerTagPrefix=project.getProperty('dockerSnapshotTagPrefix')
				
				if ("${dockerDeployRepositoryHost}".toString().isEmpty()) {
					logInfo("Can't push docker image because of empty repository setting dockerSnapshotRepositoryHost.")
				} 
			} else {
				dockerDeployRepositoryHost=project.getProperty('dockerRepositoryHost')
				dockerTagPrefix=project.getProperty('dockerTagPrefix')
				
				if ("${dockerDeployRepositoryHost}".toString().isEmpty()) {
					logInfo("Can't push docker image because of empty repository setting dockerRepositoryHost.")
				} 
			}

			if ("${dockerDeployRepositoryHost}".toString().isEmpty()) {
				printInfo("> Ignore dockerPush (no host defined to where to push).")
			} else {
				def exitStatus=0
				def loginFirst=((project.hasProperty('dockerRepositoryUser') && !project.getProperty('dockerRepositoryUser').toString().isEmpty())
								 && (project.hasProperty('dockerRepositoryPassword') && !project.getProperty('dockerRepositoryPassword').toString().isEmpty()))
				if (loginFirst) {
					printInfo("> Login docker host: " +colorize(HIGHLITE_LEVEL,  dockerDeployRepositoryHost) + ".")
					def cmd="docker login --username " + project.getProperty('dockerRepositoryUser') + " --password"
					
					def cmdDockerDeployRepositoryHost = dockerDeployRepositoryHost
					if ("$cmdDockerDeployRepositoryHost".toString().startsWith("https://hub.docker.com")) {
					    cmdDockerDeployRepositoryHost = "" // in case it's dockerhub just ignore the repository host because it don't work stable on windows
					}
					exitStatus = execDocker("$cmd " + project.getProperty('dockerRepositoryPassword') + " $cmdDockerDeployRepositoryHost", "Could not login into docker host:\n    " + cmd + " ... $dockerDeployRepositoryHost")
				} 
				
				if (exitStatus==0) {
					def dockerBuildName="${rootProject.name}:${project.version}"
					if( project.hasProperty("dockerName") && !project.getProperty("dockerName").toString().isEmpty() ) {
						dockerBuildName="$dockerName"
					}

					def tagName="$dockerTagPrefix".toString().trim()
					if (!tagName.toString().trim().isEmpty()) {
						tagName = "${tagName}/"
					}
					tagName = "${tagName}$dockerBuildName"
					
					printInfo("> Tag docker image " + colorize(HIGHLITE_LEVEL, tagName) + ".")
					def cmd="docker tag $dockerBuildName $tagName"
					exitStatus = execDocker(cmd, "Could not tag image:\n    " + cmd)
					
					if (exitStatus==0) {
						printInfo("> Push docker image " +colorize(HIGHLITE_LEVEL, tagName) + ".")
						cmd="docker push $tagName"
						exitStatus = execDocker(cmd, "Could not push image to docker host:\n    " + cmd)
						
						if( project.hasProperty("dockerCleanupAfterPublish") && project.getProperty("dockerCleanupAfterPublish") ) {
							printInfo("> Remove local docker image " +colorize(HIGHLITE_LEVEL, dockerBuildName) + ".")
							cmd="docker image remove $dockerBuildName"
							exitStatus = execDocker(cmd, "Could not remove project tag:\n    " + cmd, false)

							printInfo("> Remove local docker image " +colorize(HIGHLITE_LEVEL, tagName) + ".")
							cmd="docker image remove $tagName"
							exitStatus = execDocker(cmd, "Could not remove repository tag:\n    " + cmd, false)
						}
					}
				}
				
				logInfo("Ended with status code: " +colorize(HIGHLITE_LEVEL, exitStatus) + colorize(INFO_LEVEL, "."))
				printLine(HIGHLITE_LEVEL, true, " exit " + exitStatus + "")
			}
		}
	} 
}


/***************************************************************************************
 * project java validation
 ***************************************************************************************/
projectValidation {
	if (project.tasks.findByName('build')) {
		dockerBuild.dependsOn build

		if (!project.getProperty('IS_NEW')) {
			def buildAlwaysDockerImageEnv=System.getenv('CB_BUILD_ALWAYS_DOCKER_IMAGE')
			def buildAlwaysDockerImageSwitchEnabled=((project.hasProperty("buildAlwaysDockerImage") && "true".toString().equalsIgnoreCase(project.getProperty("buildAlwaysDockerImage").toString()))
														|| (buildAlwaysDockerImageEnv!=null && !buildAlwaysDockerImageEnv.toString().trim().isEmpty() && "true".equalsIgnoreCase(buildAlwaysDockerImageEnv.toString().trim())));

			if (buildAlwaysDockerImageSwitchEnabled && checkDockerInstallation()) {
				logInfo("Enable build always docker image.")
				build.finalizedBy(dockerBuild)
				publish.finalizedBy(dockerPush)
			}
		}
	}
}