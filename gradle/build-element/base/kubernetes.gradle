/*
 * kubernetes.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * MIT License: https://mit-license.org
 */


/***************************************************************************************
 * Check if kubernetes installation is ready to use
 ***************************************************************************************/
setCommonGradleDefaultPropertyIfNull("kubernetesFileTemplateName", "kubernetes.yaml.template")

ext.kubernetesInstallationValidated=false
ext.kubernetesInstallationCommandAvailable=false
ext.checkKubernetesInstallation = { ->
	if (!kubernetesInstallationValidated) {
		kubernetesInstallationValidated=true
		def exitStatus = execCommand("kubectl version")
		kubernetesInstallationCommandAvailable=(exitStatus==0)
		
		if (kubernetesInstallationCommandAvailable) {
			logInfo("Kubernetes installation is available.")
		} else {
			setCommonGradleProperty("errorMessagePrefix", "")
			addError("Missing kubernetes installation.")
		}
	}
	
	return kubernetesInstallationAvailable
} 


/***************************************************************************************
 * Execute kubernetes command
 ***************************************************************************************/
ext.execKubernetes = { cmd, errorMessage ->
	def sout = new StringBuilder(), serr = new StringBuilder()				
	def exitStatus = execCommand(cmd, -1, sout, serr)
	if (exitStatus>0) {
		addError("$errorMessage")
		if (sout!=null && !sout.toString().isEmpty()) {
			addError(sout.toString())
		}
		if (serr!=null && !serr.toString().isEmpty()) {
			addError(serr.toString())
		}
		
		throw new GradleException(errorMessage)		
	}
	
	return exitStatus
}


/***************************************************************************************
 * Replace namespace
 ***************************************************************************************/
ext.replaceNamespace = { line, namespace -> 
	def preparedLine = line;		
	def namespaceTag = "namespace:"
	if (namespace!=null && !namespace.toString().trim().isEmpty()) {
		int idx = preparedLine.indexOf(namespaceTag)
		if (idx>0) {
			def i = idx + namespaceTag.length()
			def rest = preparedLine.substring(i + 1).trim()
			preparedLine = preparedLine.substring(0, i)							
			preparedLine = "${preparedLine} ${namespace}"
			idx = rest.indexOf(" ")
			if (idx>0) {
				preparedLine = "${preparedLine}${rest.substring(idx)}" 
			}
		}
	}
	
	return preparedLine
}


/***************************************************************************************
 * Download and replace
 ***************************************************************************************/
ext.downloadAndReplace = { inputFileUrl, destFile, namespace -> 
	def count = 0
	try {
		def namespaceTag = "namespace:"
		def remoteFile = new File(new URL(inputFileUrl.toString()).toURI())
		def resultFile = new File(destFile.toString())
		resultFile.withWriter { writer ->
			remoteFile.withReader{ reader ->
				while (line = reader.readLine()) {
					def exportLine = replaceNamespace(line, namespace)
					
					if (!exportLine.equals(line)) {
						count++
					}
					writer << "${exportLine}" << NELINE
				}
			}
		}
	} catch(Exception e) {
	}
	
	return count
}


/***************************************************************************************
 * Get kubernetes application configuration
 ***************************************************************************************/
task kubernetesApplicationConfig() {
	group = 'Build'
	description = 'Creates kubernetes application configuration'
	onlyIf { return project.hasProperty("createApplicationConfigFile") && project.getProperty("createApplicationConfigFile") }
	
	doLast {
		logInfo("Create kubernetes application / secret configuration.")
		createFileFromTemplate("$kubernetesConfigurationPath/$kubernetesApplicationConfigFilename", getTemplateFile('kubernetes-application-config.template', 'kubernetes'))
		
		if (project.hasProperty('kubernetesApplicationOIDCPublicKey') && !project.getProperty('kubernetesApplicationOIDCPublicKey').toString().isEmpty()) {
			createFileFromTemplate("$kubernetesConfigurationPath/$kubernetesApplicationSecretFilename", getTemplateFile('kubernetes-application-secret.template', 'kubernetes'))
		}
		
		createFileFromTemplate("$kubernetesConfigurationPath/$kubernetesDatabaseSecretFilename", getTemplateFile('kubernetes-database-secret.template', 'kubernetes'))
	}
}


/***************************************************************************************
 * Create kubernetes configuration 
 ***************************************************************************************/
task kubernetesConfiguration() {
	group = 'Build'
	description = 'Creates kubernetes configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupport') && project.getProperty('kubernetesSupport') }

	if (project.hasProperty('kubernetesProjectConfiguration') && project.getProperty('kubernetesProjectConfiguration')) {
		doLast {
			// add docker prefix tag
			def dockerTagPrefix = ""
			if (project.ext.isSnapshotVersion) {
				dockerTagPrefix = project.getProperty('dockerSnapshotTagPrefix')
			} else {
				dockerTagPrefix = project.getProperty('dockerTagPrefix')
			}
			dockerTagPrefix = "$dockerTagPrefix".toString().trim()
			if (!dockerTagPrefix.toString().isEmpty()) {
				dockerTagPrefix = "${dockerTagPrefix}/"
			}
			setCommonGradleDefaultPropertyIfNull("kubernetesDockerImage", "${dockerTagPrefix}${rootProject.name}:${project.version}")
			new File("$kubernetesConfigurationPath").mkdirs()
			
			def kubernetesFilename="${rootProject.name}-kubernetes.yaml"
			logInfo("Create kubernetes configuration " + colorize(HIGHLITE_LEVEL, kubernetesFilename) + ".")
			createFileFromTemplate("$kubernetesConfigurationPath/$kubernetesFilename", getTemplateFile('kubernetes.yaml.template'))
		}
	}
}

/***************************************************************************************
 * Prepare project specific kubernetes artefacts
 ***************************************************************************************/
if (new File(srcKubernetesDirectory).exists()) {
	task projectKubernetesArtefacts() {
		group = 'Build'
		description = 'Add project kubernetes configuration'
		
		doLast {
			new File("$gradleBuildDirectory").mkdirs()
			new File("$kubernetesConfigurationPath").mkdirs()
			new File("$kubernetesConfigurationElementsPath").mkdirs()

			// workaround: manipulate the template path to use the same search / replace functionality
			def backupTemplatePath = project.getProperty('commonGradleTemplatePath')
			setCommonGradleProperty('commonGradleTemplatePath', "$srcKubernetesDirectory")

			def kubernetesFilename="${rootProject.name}-kubernetes.yaml"
			def fileContent = new File("$kubernetesConfigurationPath/$kubernetesFilename")
			def isNewFile = false
			if (!fileContent.exists()) {
				isNewFile = true
				fileContent.createNewFile() 
			}
			
			new File(srcKubernetesDirectory).eachFileRecurse (groovy.io.FileType.FILES) { file ->
				def kubernetesServicesFilename = "$kubernetesConfigurationElementsPath/${rootProject.name}-kubernetes.yaml"
				if (file.getName().toString().endsWith(".template")) {
					printInfo("> Prepare kubernetes template " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")
					createFileFromTemplate("$kubernetesServicesFilename", "" + file.getName(), true, false)
				} else {
					printInfo("> Copy kubernetes file " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")
					copyFile("${file}", "$kubernetesServicesFilename")
				}
				
				new File(kubernetesServicesFilename).withReader {
					def header = true
					if (!isNewFile) {
						fileContent.append("---" + NELINE)
						fileContent.append("# Source: " + file.getName() + NELINE)
					} else {
						header = false
					}
					
					def line
					while ((line = it.readLine()) != null) {
						def ignoreLine = line.startsWith("#") || line.toString().trim().isEmpty()
						if (header && ignoreLine) {
						} else {
							header = false
							fileContent.append(line + NELINE)
						}
					}
				}
			}
			
			setCommonGradleProperty('commonGradleTemplatePath', backupTemplatePath)
		}
	}
	kubernetesConfiguration.finalizedBy(projectKubernetesArtefacts)
}

/***************************************************************************************
 * Build kubernetes jar file
 ***************************************************************************************/
task kubernetesJar(type: Jar, dependsOn: 'kubernetesConfiguration') { jar ->
	group = 'Build'
	description = 'Assembles the kubernetes configuration into a jar file'
	onlyIf { return project.hasProperty('kubernetesSupport') && project.getProperty('kubernetesSupport') }

	into "kubernetes", {
		from "${kubernetesConfigurationPath}"
	}

	// include readme, license and version files
	into 'META-INF', {
		if (project.getProperty('includeReadmeFile')) {
			from "${readmeFile}"
		}

		if (project.getProperty('includeLicenseFile')) {
			from "${licenseFile}"
		}

		if (project.getProperty('includeVersionFile')) {
			from "${versionFile}"
		}

		if (project.getProperty('includeChangelogFile')) {
			from "${changelogFile}"
		}
	}

	archiveClassifier = 'kubernetes'

	// define proper manifest
	manifest {
		attributes 	'Specification-Title'   : rootProject.name,
					'Specification-Version' : project.version,
					'Implementation-Title'  : rootProject.name,
					'Implementation-Version': project.version + project.ext.scmVersionNumber,
					'Created-By'		   	: project.ext.buildToolVersionStackMessage,
					'Built-By'			   	: publishingUsername,
					'Build-Timestamp'	   	: BUILD_TIMESTAMP,
					'Build-OS'			   	: "${System.properties['os.name']} (${System.properties['os.version']}), ${System.properties['os.arch']}"
	}

	doLast {
		if (project.hasProperty('showCreatedArtefacts') && project.getProperty('showCreatedArtefacts')) {
			// jar.archiveFileName
			def filename = prepareFilename(jar.archivePath.getPath())
			printInfo("> Created package " + colorize(HIGHLITE_LEVEL, filename) + ".")
		}
	}
}
