/*
 * container.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * 
 * This file is part of the toolarium common-gradle-build.
 * 
 * The common-gradle-build is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The common-gradle-build is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar. If not, see <http://www.gnu.org/licenses/>.
 */


/***************************************************************************************
 * Check if container installation is ready to use
 ***************************************************************************************/
//setCommonGradleDefaultPropertyIfNull("dockerFileTemplateName", "Dockerfile-node.properties.template")
setCommonGradleDefaultPropertyIfNull("dockerFileTemplateName", "Dockerfile.properties.template")
setCommonGradleDefaultPropertyIfNull("IS_NEW_SRC_FOLDER", false)
setCommonGradleDefaultPropertyIfNull("createApplicationConfigFile", false)
setCommonGradleDefaultPropertyIfNull("containerCmd", "nerdctl")

ext.dockerExecuteAsScript=false
ext.dockerExecuteNotAsAbsolutePath=false
ext.dockerInstallationValidated=false
ext.dockerInstallationCommandAvailable=false
ext.dockerInstallationAvailable=false
ext.checkDockerInstallation = { ->
	if (!dockerInstallationValidated) {
		dockerInstallationValidated=true
		def stdout = new StringBuilder()

		def exitStatus = -1
		try { 
			exitStatus = execCommand("${containerCmd} --version", -1, stdout, stdout)
			if (exitStatus==0) {
				exitStatus = execCommand("${containerCmd} info")
			}
		} catch(Exception e) {
			// NOP
		}

		if (exitStatus!=0) {
			stdout = new StringBuilder()
			exitStatus = execCommand("docker --version", -1, stdout, stdout)
			if (exitStatus==0) {
				setCommonGradleProperty("containerCmd", "docker")
				setCommonGradleProperty("dockerBuildPull", "--pull --force-rm")
				setCommonGradleProperty("dockerBuildCompress", "--compress")
			}
		} else {
			// use nerdctl -> check if there is a linux environment: in version 1.12 there is an issue with absolute path
			if ("linux".equals(getOsName())) {
				logInfo("Use docker file from build path for build.")
				dockerExecuteNotAsAbsolutePath=true
				dockerExecuteAsScript=true
			}
		}
		logInfo("Use ${containerCmd} as container build tool.")
		dockerInstallationCommandAvailable=(exitStatus==0)
		
		if (dockerInstallationCommandAvailable) {
			logInfo("Container installation is available.")
			
			exitStatus = execCommand("${containerCmd} info")
			dockerInstallationAvailable=(exitStatus==0)

			if (dockerInstallationAvailable) {
				logInfo("Container installation is ready (${containerCmd}).")
			} else {
				setCommonGradleProperty("errorMessagePrefix", "")
				addError("Container installation is not ready (${containerCmd}).")
			}
		} else {
			setCommonGradleProperty("errorMessagePrefix", "")
			addError("Missing container installation.")
		}
	}
	
	return dockerInstallationAvailable
} 


/***************************************************************************************
 * Execute container command
 ***************************************************************************************/
ext.execDocker = { cmd, errorMessage, failOnError = true ->
	def sout = new StringBuilder(), serr = new StringBuilder()				
	def exitStatus = execCommand(cmd, -1, sout, serr)
	if (exitStatus>0) {
		if (failOnError) {
			addError("$errorMessage")
			if (sout!=null && !sout.toString().isEmpty()) {
				addError(sout.toString())
			}
			if (serr!=null && !serr.toString().isEmpty()) {
				addError(serr.toString())
			}
			
			throw new GradleException(errorMessage)		
		} else {
			printWarn("$errorMessage")
		}
	}
	
	return exitStatus
}


/***************************************************************************************
 * container build task
 ***************************************************************************************/
task dockerBuild {
	group = 'Build'
	description = 'Create a container image.'
	onlyIf { return validBuild }

	doLast {
		if (!project.getProperty('IS_NEW') && checkDockerInstallation()) {
			def dockerSourceMessage="project"
			def deleteDockerIgnoreFile=false
			def localDockerFileExist=new File("$dockerFile").exists()
			def localDockerTemplateFileExist=new File("$dockerFileTemplate").exists()
			def localFileExist=(localDockerFileExist || localDockerTemplateFileExist)
			def supportProjectDockerfile=project.hasProperty("projectIndividualDockerfie") && project.getProperty("projectIndividualDockerfie")
			def createProjectDockerfile=project.hasProperty("createProjectIndividualDockerfie") && project.getProperty("createProjectIndividualDockerfie")
			def tempDockerFile=getUniqueTempName("${rootProject.name}", "${project.version}-dockerfile", null)

			if (project.hasProperty('dockerSupportProjectTemplateList') && project.getProperty('dockerSupportProjectTemplateList') && project.hasProperty('allowedDockerfileTemplateProjects')) {
				def allowedDockerfileTemplateProjectList = new ArrayList(Arrays.asList(allowedDockerfileTemplateProjects.split(", ")))
				if (allowedDockerfileTemplateProjectList!=null && !allowedDockerfileTemplateProjectList.isEmpty() && !allowedDockerfileTemplateProjectList.contains("${rootProject.name}".toString())) {
					supportProjectDockerfile = false
					createProjectDockerfile = false
					
					if (localFileExist) {
						def ignoreDockerFilename = "$dockerFileTemplate"
						if (localDockerFileExist) {
							ignoreDockerFilename = "$dockerFile"
						}
						
						printWarn("This project is not allowed to have own file " +colorize(HIGHLITE_LEVEL, ignoreDockerFilename) + "!")
						if ("true".equalsIgnoreCase("" + project.getProperty('isReleaseVersion'))) {
							addError("Found not supported dockerfile ${ignoreDockerFilename}!")
						}
					}
				}
			}
	
			if (supportProjectDockerfile && createProjectDockerfile) {			
				if (!localFileExist) {
					// create local file in project 
					createFileFromTemplate("$dockerFileTemplate", getTemplateFile("$dockerFileTemplateName"), true, true, false /* keep template*/)
					
					if (project.hasProperty('dockerIgnoreFilename') && !project.getProperty('dockerIgnoreFilename').toString().isEmpty()) {
						createFileFromTemplate("$dockerIgnoreFile", getTemplateFile('dockerignore.template'))
					}
					
					// create from local file
					localDockerTemplateFileExist = createFileFromTemplate("$tempDockerFile", "$dockerFileTemplate")
					localFileExist=(localDockerFileExist || localDockerTemplateFileExist)
				}

				if (localDockerFileExist) {
					// create from local file
					printInfo("> Prepare dockerfile from " +colorize(HIGHLITE_LEVEL,  dockerFile) + " (new).")
					dockerSourceMessage="project"
					copyFile("$dockerFile", "$tempDockerFile")
				} else {
					printInfo("> Prepare dockerfile from template " +colorize(HIGHLITE_LEVEL,  dockerFileTemplate) + " (new).")
					dockerSourceMessage="project template"
					// create from local file
					createFileFromTemplatePath(tempDockerFile, getFilePath(dockerFileTemplate), "", getFilename(dockerFileTemplate), true, false)
				}
			} else if (supportProjectDockerfile && localFileExist) {
				if (localDockerFileExist) {
					// create from local file
					printInfo("> Prepare dockerfile from " + colorize(HIGHLITE_LEVEL,  dockerFile) + ".")
					dockerSourceMessage="project"
					copyFile("$dockerFile", "$tempDockerFile")
				} else {
					printInfo("> Prepare dockerfile from template " +colorize(HIGHLITE_LEVEL,  dockerFileTemplate) + ".")
					dockerSourceMessage="project template"
					createFileFromTemplatePath(tempDockerFile, getFilePath(dockerFileTemplate), "", getFilename(dockerFileTemplate), true, false)
				}

				if (!new File("$dockerIgnoreFile").exists() && !"$dockerIgnoreFile".toString().isEmpty()) {
					printInfo("> Create temporary " +colorize(HIGHLITE_LEVEL,  dockerIgnoreFile) + ".")
					deleteDockerIgnoreFile=true
					createFileFromTemplate("$dockerIgnoreFile", getTemplateFile('dockerignore.template'), false, false)
				}
			} else {
				printInfo("> Prepare dockerfile from template " +colorize(HIGHLITE_LEVEL, "/" + getTemplateFile("$dockerFileTemplateName")) + ".")
				dockerSourceMessage="global"
				createFileFromTemplate("$tempDockerFile", getTemplateFile("$dockerFileTemplateName"), true, false)

				if (!new File("$dockerIgnoreFile").exists() && !"$dockerIgnoreFile".toString().isEmpty()) {
					printInfo("> Create temporary " +colorize(HIGHLITE_LEVEL,  dockerIgnoreFile) + ".")
					deleteDockerIgnoreFile=true
					createFileFromTemplate("$dockerIgnoreFile", getTemplateFile('dockerignore.template'), false, false)
				}
			}
			
			def dockerBuildName="${rootProject.name}:${project.version}"
			logInfo("Use dockerfile [" +colorize(HIGHLITE_LEVEL, tempDockerFile) + colorize(INFO_LEVEL, "]."))
			if (project.hasProperty("dockerName") && !project.getProperty("dockerName").toString().isEmpty()) {
				dockerBuildName="$dockerName"
			}
			
			if (tempDockerFile.startsWith("./")) {
				tempDockerFile = cbProjectRootDir + "/" + tempDockerFile.substring(2)
			}
				
			printInfo("> Create container image " + colorize(HIGHLITE_LEVEL,  dockerBuildName) + " (${dockerSourceMessage} dockerfile)")
			logInfo("Use dockerfile [" +colorize(HIGHLITE_LEVEL,  dockerBuildName) + colorize(INFO_LEVEL, "]."))
			
			def cmd="${containerCmd} build -t ${dockerBuildName} ${dockerBuildPull} ${dockerBuildCompress}"
			if (!"${dockerBuildArgs}".toString().trim().isEmpty()) {
				cmd="$cmd ${dockerBuildArgs}"
			}
	
			// in case docker or nerdctl has issues to reference absolute path referenced file, e.g. nerdctl v1.12
			def localName = "dockerfile"
			def execPath=""
			def idx = tempDockerFile.lastIndexOf("/")
			if (idx>0) {
				execPath = tempDockerFile.substring(0, idx);
				localName = tempDockerFile.substring(idx)
			}
			
			if(dockerExecuteNotAsAbsolutePath) {
				copyFile("$tempDockerFile", "$cbProjectRootDir/build/$localName")
				new File("$tempDockerFile").delete()
				tempDockerFile="$cbProjectRootDir/build/$localName"
			}
		
			def tempDockerFileScript = ""
			if (dockerExecuteAsScript) {
				tempDockerFileScript = execPath + "/" + localName
				if ("windows" == getOsName()) {
					tempDockerFileScript = "${tempDockerFileScript}.bat"
					new File(tempDockerFileScript).text = """
cd $execPath
$cmd -f ${tempDockerFile} $cbProjectRootDir
"""
				} else {
					tempDockerFileScript = "${tempDockerFileScript}.sh"
					new File(tempDockerFileScript).text = """
#!/bin/sh
cd $execPath
$cmd -f ${tempDockerFile} $cbProjectRootDir
"""
					def sout = new StringBuilder(), serr = new StringBuilder()
					def exitStatus = execCommand("chmod +x $tempDockerFileScript", -1, sout, serr)
				}

				cmd="$tempDockerFileScript"
			} else {
				cmd="$cmd -f ${tempDockerFile} $cbProjectRootDir"
			}
		
			def exitStatus = execDocker(cmd, "Could not build container image:\n    " + cmd)
			if (exitStatus==0) {
				if( project.hasProperty("dockerCleanupAfterBuild") && project.getProperty("dockerCleanupAfterBuild") ) {
					printInfo("> Remove container image " +colorize(HIGHLITE_LEVEL, dockerBuildName) + ".")
					cmd="${containerCmd} image remove $dockerBuildName"
					exitStatus = execDocker(cmd, "Could not remove project tag:\n    " + cmd, false)
				}
			}
			
			new File("$tempDockerFile").delete()
			if (dockerExecuteAsScript && !"$tempDockerFileScript".toString().isEmpty()) {
				new File("$tempDockerFileScript").delete()
			}
			
			if (deleteDockerIgnoreFile) {
				logInfo("Remove dockerignore " +colorize(HIGHLITE_LEVEL, dockerIgnoreFile) + ".")
				new File("$dockerIgnoreFile").delete()
			}

			cmd="${containerCmd} image ls ${rootProject.name}:${project.version} --format json"
			def sout = new StringBuilder()
			exitStatus = execCommand(cmd, -1, sout, sout)
			if (exitStatus!=0) {
				def message = "Could not read container images:\n    " + colorize(HIGHLITE_LEVEL, cmd) + ":"
				if (sout!=null && !sout.toString().isEmpty()) {
					message = "${message}" + sout.toString()
				}
				logInfo(message)
			} else {
				try {
					def images = new groovy.json.JsonSlurper().parseText(sout.toString())
					//images.get("CreatedAt") // "2024-01-25 13:31:36 +0100 CET"
					
					def sizeStr = images.get("Size")
					for (int i = 0; i<sizeStr.length(); i++) {
						def ch = sizeStr.toString().charAt(i)
						if (!Character.isDigit(ch) && !".".equals("" + ch) && !("" + ch).toString().trim().isEmpty()) {
							sizeStr = sizeStr.substring(0, i) + " " + sizeStr.substring(i)
							break;
						}
					}
					printInfo("> Container images id " + colorize(HIGHLITE_LEVEL, "" + images.get("ID")) + ": " + colorize(HIGHLITE_LEVEL, sizeStr) + " (base:" + colorize(HIGHLITE_LEVEL,  dockerImage) + ")")
				} catch (Exception e) {
					printWarn("Could not add artefact depdendency: " + e.getMessage())
					throw e
				}
			}

			if (project.hasProperty("dockerRemoveDanglingImages") && project.getProperty("dockerRemoveDanglingImages")) {
				printInfo("> Remove all dangling images...")
				sout = new StringBuilder()
				exitStatus = execCommand("${containerCmd} images -f 'dangling=true' -q", -1, sout, null)
				if (exitStatus==0) {
					sout.eachLine {line, count ->
						logInfo("Remove dangling image ${line}...")
						cmd="${containerCmd} rmi -f ${line}"
						execDocker(cmd, "Could not prune dangling image (${line}):\n    " + cmd, false)
					}
				}
			}
		}
	} 
}


/***************************************************************************************
 * container build task
 ***************************************************************************************/
task dockerRun {
	group = 'Build'
	description = 'Run a container image.'
    dependsOn dockerBuild 

	doLast {
		if (!project.getProperty('IS_NEW') && checkDockerInstallation()) {
			def dockerBuildName="${rootProject.name}:${project.version}"
			if( project.hasProperty("dockerName") && !project.getProperty("dockerName").toString().isEmpty() ) {
				dockerBuildName="$dockerName"
			}
			
			printInfo("> Run container image " +colorize(HIGHLITE_LEVEL,  dockerBuildName) + ".")
			def cmd="${containerCmd} run $dockerBuildName --rm".toString()
			printLine()
			def exitStatus = execDocker(cmd, "Could not run container image:\n    " + cmd)
			logInfo("Ended with status code: " +colorize(HIGHLITE_LEVEL, exitStatus) + colorize(INFO_LEVEL, "."))
			printLine(HIGHLITE_LEVEL, true, " exit " + exitStatus + "")
		}
	} 
}


/***************************************************************************************
 * docker build task
 ***************************************************************************************/
task dockerPush {
	group = 'Build'
	description = 'Pusha container image.'
    dependsOn dockerBuild 
	onlyIf { return project.hasProperty('validBuild') && project.getProperty('validBuild') }

	doLast {
		if (!project.getProperty('IS_NEW') && checkDockerInstallation()) {
			def dockerDeployRepositoryHost = ""
			def dockerTagPrefix = ""
			if (project.ext.isSnapshotVersion) {
				dockerDeployRepositoryHost=project.getProperty('dockerSnapshotRepositoryHost')
				dockerTagPrefix=project.getProperty('dockerSnapshotTagPrefix')
				
				if ("${dockerDeployRepositoryHost}".toString().isEmpty()) {
					logInfo("Can't push container image because of empty repository setting dockerSnapshotRepositoryHost.")
				} 
			} else {
				dockerDeployRepositoryHost=project.getProperty('dockerRepositoryHost')
				dockerTagPrefix=project.getProperty('dockerTagPrefix')
				
				if ("${dockerDeployRepositoryHost}".toString().isEmpty()) {
					logInfo("Can't push container image because of empty repository setting dockerRepositoryHost.")
				} 
			}

			if ("${dockerDeployRepositoryHost}".toString().isEmpty()) {
				printInfo("> Ignore dockerPush (no host defined to where to push).")
			} else {
				def exitStatus=0
				def loginFirst=((project.hasProperty('dockerRepositoryUser') && !project.getProperty('dockerRepositoryUser').toString().isEmpty())
								 && (project.hasProperty('dockerRepositoryPassword') && !project.getProperty('dockerRepositoryPassword').toString().isEmpty()))
				if (loginFirst) {
					printInfo("> Login container host: " +colorize(HIGHLITE_LEVEL,  dockerDeployRepositoryHost) + ".")
					def cmd="${containerCmd} login --username " + project.getProperty('dockerRepositoryUser') + " --password"
					
					def cmdDockerDeployRepositoryHost = dockerDeployRepositoryHost
					if ("$cmdDockerDeployRepositoryHost".toString().startsWith("https://hub.docker.com")) {
					    cmdDockerDeployRepositoryHost = "" // in case it's dockerhub just ignore the repository host because it don't work stable on windows
					}
					exitStatus = execDocker("$cmd " + project.getProperty('dockerRepositoryPassword') + " $cmdDockerDeployRepositoryHost", "Could not login into container host:\n    " + cmd + " ... $dockerDeployRepositoryHost")
				} 
				
				if (exitStatus==0) {
					def dockerBuildName="${rootProject.name}:${project.version}"
					if( project.hasProperty("dockerName") && !project.getProperty("dockerName").toString().isEmpty() ) {
						dockerBuildName="$dockerName"
					}

					def baseTagName="$dockerTagPrefix".toString().trim()
					if (!baseTagName.toString().trim().isEmpty()) {
						baseTagName = "${baseTagName}/"
					}
					def tagName = "${baseTagName}$dockerBuildName"
					
					printInfo("> Tag container image " + colorize(HIGHLITE_LEVEL, tagName) + ".")
					def cmd="${containerCmd} tag $dockerBuildName $tagName"
					exitStatus = execDocker(cmd, "Could not tag image:\n    " + cmd)
					
					if (exitStatus==0) {
						printInfo("> Push container image " +colorize(HIGHLITE_LEVEL, tagName) + ".")
						cmd="${containerCmd} push $tagName"
						exitStatus = execDocker(cmd, "Could not push image to container host:\n    " + cmd)
/*
						if (project.hasProperty('dockerBuildLatestTag') && "true".equalsIgnoreCase("" + project.getProperty('dockerBuildLatestTag'))) {
							def dockerBuildLatestName = ""
							if( project.hasProperty("dockerBuildLatestTagName") && !project.getProperty("dockerBuildLatestTagName").toString().isEmpty() ) {
								dockerBuildLatestName="$dockerBuildLatestTagName"
							} else {
								dockerBuildLatestName="${baseTagName}${rootProject.name}:" + project.getProperty('majorVersionNumber') + "." + project.getProperty('minorVersionNumber') + "." + project.getProperty('revisionVersionNumber') + ".latest"
							}

							printInfo("> Tag container image " + colorize(HIGHLITE_LEVEL, dockerBuildLatestName) + ".")
							def cmd="${containerCmd} tag $dockerBuildName $dockerBuildLatestName"
							exitStatus = execDocker(cmd, "Could not tag image:\n    " + cmd)
							
							if (exitStatus==0) {
								printInfo("> Push container image " +colorize(HIGHLITE_LEVEL, dockerBuildLatestName) + ".")
								cmd="${containerCmd} push $dockerBuildLatestName"
								exitStatus = execDocker(cmd, "Could not push image to container host:\n    " + cmd)
							}
						}
*/						
						
						if( project.hasProperty("dockerCleanupAfterPublish") && project.getProperty("dockerCleanupAfterPublish") ) {
							printInfo("> Remove local container image " +colorize(HIGHLITE_LEVEL, dockerBuildName) + ".")
							cmd="${containerCmd} image remove $dockerBuildName"
							exitStatus = execDocker(cmd, "Could not remove project tag:\n    " + cmd, false)

							printInfo("> Remove local container image " +colorize(HIGHLITE_LEVEL, tagName) + ".")
							cmd="${containerCmd} image remove $tagName"
							exitStatus = execDocker(cmd, "Could not remove repository tag:\n    " + cmd, false)
						}
					}
				}
				
				logInfo("Ended with status code: " +colorize(HIGHLITE_LEVEL, exitStatus) + colorize(INFO_LEVEL, "."))
				printLine(HIGHLITE_LEVEL, true, " exit " + exitStatus + "")
			}
		}
	} 
}


/***************************************************************************************
 * project java validation
 ***************************************************************************************/
projectValidation {
	if (project.tasks.findByName('build')) {
		dockerBuild.dependsOn("build") // e.g.: build or buildFatWebJar
		if (!"dockerBuild".toString().equals("${taskNameBeforeReleaseArtefacts}".toString())) {
			dockerBuild.mustRunAfter("build")
			dockerBuild.mustRunAfter("${taskNameBeforeReleaseArtefacts}") // e.g.: build or dockerBuild
		}

		if (!project.getProperty('IS_NEW')) {
			def buildAlwaysDockerImageEnv=System.getenv('CB_BUILD_ALWAYS_DOCKER_IMAGE')
			def buildAlwaysDockerImageSwitchEnabled=((project.hasProperty("buildAlwaysDockerImage") && "true".toString().equalsIgnoreCase(project.getProperty("buildAlwaysDockerImage").toString()))
														|| (buildAlwaysDockerImageEnv!=null && !buildAlwaysDockerImageEnv.toString().trim().isEmpty() && "true".equalsIgnoreCase(buildAlwaysDockerImageEnv.toString().trim())));

			if (buildAlwaysDockerImageSwitchEnabled && checkDockerInstallation()) {
				logInfo("Enable build always container image.")
				build.finalizedBy(dockerBuild)
				publish.finalizedBy(dockerPush)
				setCommonGradleProperty("taskNameBeforeReleaseArtefacts", "dockerBuild") 
			}
		}
	}
}