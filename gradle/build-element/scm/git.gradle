/*
 * git.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * MIT License: https://mit-license.org
 */


addCommonGradlePropertyList("allowedMainDirectories", "$rootDirectory/.git")
addCommonGradlePropertyList("allowedMainFiles", "$rootDirectory/.gitattributes")
addCommonGradlePropertyList("allowedMainFiles", "$rootDirectory/.gitignore")
buildscript {
	repositories {
		jcenter()
	}
	dependencies {
		classpath 'org.ajoberstar.grgit:grgit-core:4.0.2'
	}
}


/** 	
 * Check if git is already initialized
 */
ext.isGitAvailable = { ->
	def gitDir = "$rootDirectory/.git"
	def gitDirectoryIsAvailable = new File(gitDir).exists()
		
	if (gitDirectoryIsAvailable) {
		logInfo("GIT directory exist.")
		
		def git = openGit()
		if (git!=null) {
			try {
				if (git.head()!=null) {
					logInfo("GIT is available.")
				} else {
					logInfo("GIT is available but has nothing in head.")
				}
				
				return true;
			} catch (IOException e) {
				logInfo("Could not read head from git: " + e.getMessage())
			} finally {
				closeGit(git)
			}
		} 
	} else{ 
		logInfo("GIT directory don't exist.")
	}
	
	return false
}


/** 	
 * Open git 
 */
ext.openGit = { directory = projectDir ->
 	try	
	{
		logInfo("Open git...")
		def git = org.ajoberstar.grgit.Grgit.open(dir: directory)
	} catch (java.lang.IllegalStateException e) {
		printLine(ERROR_LEVEL, true)
		printInfo(colorize(ERROR_LEVEL, 'ERROR') + ": Can not access to git repository: " + e.getMessage() )
		printInfo("      In case you have to authenticate, please use system environment " + colorize(HIGHLITE_LEVEL, 'GRGIT_USER') + " and " + colorize(HIGHLITE_LEVEL, 'GRGIT_PASS') + "!")
		printLine(ERROR_LEVEL, true)
		throw new GradleException("Can not access to git repository: " + e.getMessage())
	}
}


/** 	
 * Close git
 */
ext.closeGit = { git -> 
	logInfo("Close git...")
	if (git!=null) {
		try {			
			git.close()
		} catch (Exception e) {
			printInfo("Could not close git: " + e.getMessage())
		}
	}
}


/**
 * Initialize git project
 */
ext.initGit = { bare = false ->
	def git = null
	
    try {
		logInfo("Initialise git...")
		git = org.ajoberstar.grgit.Grgit.init(dir: projectDir, bare: bare)
		logInfo("Initialized git.")
	} catch (Exception e) {
		printWarn("Could not initialize git: " + e.getMessage())
	} finally {
		closeGit(git)
	}	
}


/**
 * Add files to git 
 */
ext.addGit = { inputPatterns = ['./'] ->
	def git = null	
	if (isGitAvailable()) {
		try {
			git = openGit()
			logInfo("Add to git...")
			git.add(patterns: inputPatterns)
		} catch (Exception e) {
			printWarn("Could not add files to git: " + e.getMessage())
		} finally {
			closeGit(git)
		}	
	}
}


/**
 * Commit git
 */
ext.commitGit = { message = "First commit" ->
	def git = null	
	if (isGitAvailable()) {
		try {
			git = openGit()
			logInfo("Commit git...")
			git.commit(message: message)
		} catch (Exception e) {
			printWarn("Could not add files to git: " + e.getMessage())
		} finally {
			closeGit(git)
		}	
	}
}


/** 
 * Read the git commit hash 
 */
ext.getGitCommitHash = { ->
	def commitHashId = "";
	if (isGitAvailable()) {
		def git = null
		try {
			git = openGit()
			if (git!=null && git.head()!=null) {
				commitHashId = git.head().id;
				if (commitHashId!=null && commitHashId.length() > 9) {
					commitHashId = commitHashId.substring(0, 9)
				}
			}
		} catch (IOException e) {
			printWarn("Could not read git commit hash: " + e.getMessage())
		} finally {
			closeGit(git)
		}	
	}	
	
	return commitHashId
}


/** 
 * Read the git last tag name
 */
ext.getGitLastTagName = { ->
	def lastTag = ""
	if (isGitAvailable()) {
		def git = null
		try {
			git = openGit()
			if (git!=null && git.tag!=null) {
				def listOfTags = git.tag.list()
			
				if (listOfTags!=null && !listOfTags.isEmpty()) {		
					def tagNames = listOfTags.collect { git.describe(commit: it.commit, tags: true) }
					lastTag = tagNames.last()
				}
			}
		} catch (IOException e) {
			printWarn("Could not read last tag name: " + e.getMessage())
		} finally {
			closeGit(git)
		}	
	}	
	
	return lastTag
}


/** 
 * Read the git branch name
 */
ext.getGitBranchName = { ->
	def git = null
	if (isGitAvailable()) {
		try {
			git = openGit()
			if (git!=null && git.branch!=null && git.branch.current()!=null) {
				return git.branch.current().name
			}
		} catch (IOException e) {
			printWarn("Could not read git branch name: " + e.getMessage())
		} finally {
			closeGit(git)
		}	
	}
	
	return ""
}


/**
 * Set a git tag name
 */
ext.setGitTagName = { tagName, message ->
	if (isGitAvailable()) {
		def git = null
		try {
			git = openGit()
			if (git!=null && git.tag!=null) {
				git.tag.add(name: tagName, message: message, force: true)
				git.push(tags: true)            
			}
		} catch (IOException e) {
			printWarn("Could not set git tag name: " + e.getMessage())
		} finally {
			closeGit(git)
		}	
	}
}


/**
 * Set a git branch name
 */
def createBranch(String versionNumber, String branchName) {
/*
  try {
		getGit()		
		if (getGitIsAvailable()) {
			ext.git.checkout(op -> {
				op.setCreateBranch(true)
				op.setBranch(branchName)
			})
			
			ext.git.add(op -> op.setPatterns(new HashSet<>(Arrays.asList("VERSOIN", "VERSION"))))
			ext.git.commit(op -> op.setMessage("Release branch for " + versionNumber))
			ext.git.push()
		}
	} catch (IOException e) {
	}
	
	return branchName;
	*/
}


/**
 * Clone a git repository
 */
ext.gitClone = { inputCloneDir, inputCloneUrl, overwrite = true ->
	
	def cloneDir = inputCloneDir.trim() //.replace('\', '/')
	def cloneUrl = inputCloneUrl.trim()
	def git = null
	
    try {
		if (!HAS_ONLINE_CONNECTION) {
			printWarn("Could not checkout [" + colorize(HIGHLITE_LEVEL, cloneUrl) + colorize(WARN_LEVEL, "] because no online connection!"))
			return
		}

		if (new File(cloneDir).exists()) {
			if (overwrite) {
				git = openGit(cloneDir)
				logInfo("GIT reset [" + colorize(HIGHLITE_LEVEL, cloneUrl) + colorize(INFO_LEVEL, "] in [") + colorize(HIGHLITE_LEVEL, cloneDir) + colorize(INFO_LEVEL, "]."))
				git.reset(mode: 'hard', commit: 'origin/master')
				logInfo("GIT clean [" + colorize(HIGHLITE_LEVEL, cloneDir) + colorize(INFO_LEVEL, "]."))
				git.clean(directories: true)
				logInfo("GIT pull [" + colorize(HIGHLITE_LEVEL, cloneDir) + colorize(INFO_LEVEL, "]."))
				git.pull()			
				return
			} 
			
			printWarn("Checkout directory already exist [" + colorize(HIGHLITE_LEVEL, cloneDir) + colorize(WARN_LEVEL, "]!"))
			return
		}

		logInfo("GIT checkout [" + colorize(HIGHLITE_LEVEL, cloneUrl) + colorize(INFO_LEVEL, "] into [") + colorize(HIGHLITE_LEVEL, cloneDir) + colorize(INFO_LEVEL, "]."))
		git = org.ajoberstar.grgit.Grgit.clone(dir: cloneDir, uri: cloneUrl)
	} catch (Exception e) {
		printWarn("Could not checkout [" + colorize(HIGHLITE_LEVEL, cloneUrl) + colorize(WARN_LEVEL, "] into [") + colorize(HIGHLITE_LEVEL, cloneDir) + colorize(WARN_LEVEL, "]: " + e.getMessage()))
	} finally {
		closeGit(git)
	}	
}


/** 
 * Read the git commit hash 
 */
def getGitCommitHashCmdline() {
    try {
		return "git rev-parse --short HEAD".execute().text.trim()
	} catch (IOException e) {
	}
	
	return ""
}


/** 
 * Read the git branch name
 */
def getGitBranchNameCmdline() {
    try {
		return "git rev-parse --abbrev-ref HEAD".execute().text.trim()
	} catch (IOException e) {
	}
	
	return ""
}


/***************************************************************************************
 * Initialize git files
 ***************************************************************************************/
ext.createGitFiles = { overwrite = false ->
	def rootDirectory = project.getProperty('rootDirectory');
	def commonGradleTemplateScmPath= project.getProperty('commonGradleTemplateScmPath')
	def gitIgnoreFile = '.gitignore'
	
	if (overwrite || !new File("${rootDirectory}", "${gitIgnoreFile}").exists()) {
		def gitIgnoreFileTemplate = 'gitignore.template'
		if (new File("${commonGradleTemplateScmPath}", "${gitIgnoreFileTemplate}").exists()) {
			printInfo("> Create " + colorize(HIGHLITE_LEVEL, gitIgnoreFile) + " from template ${gitIgnoreFileTemplate}.")
			copy {
				from "${commonGradleTemplateScmPath}"
				include "${gitIgnoreFileTemplate}"
				into "${rootDirectory}"
				rename { String fileName -> fileName.replace(gitIgnoreFileTemplate, gitIgnoreFile) }
			}
		} else {		
			printInfo("> Create " + colorize(HIGHLITE_LEVEL, gitIgnoreFile) + " with default values.")
			new File(rootDirectory, gitIgnoreFile).withWriterAppend { w ->
				w << "# Ignore Gradle project-specific cache directory" << NELINE \
				<< ".gradle" << NELINE \
				<< NELINE \
				<< "# Ignore Gradle build output directory" << NELINE \
				<< "build" << NELINE \
				<< NELINE \
				<< "# Ignore logs output directory" << NELINE \
				<< "logs" << NELINE \
				<< NELINE \
				<< "# Ignore temp output directory" << NELINE \
				<< "temp" << NELINE \
				<< NELINE
			}
		}
	}
		
	def classpathFile = ".classpath"
	def gitAttributeFile = '.gitattributes'
	if (overwrite || !new File("${rootDirectory}", "${gitAttributeFile}").exists()) {
		def gitAttributeFileTemplate = 'gitattributes.template'
		if (new File("${commonGradleTemplateScmPath}", "${gitAttributeFileTemplate}").exists()) {
			printInfo("> Create " + colorize(HIGHLITE_LEVEL, gitAttributeFile) + " from template ${gitAttributeFileTemplate}.")
			copy {
				from "${commonGradleTemplateScmPath}"
				include "${gitAttributeFileTemplate}"
				into "${rootDirectory}"
				rename { String fileName -> fileName.replace(gitAttributeFileTemplate, gitAttributeFile) }
			}
		} else {		
			printInfo("> Create " + colorize(HIGHLITE_LEVEL, gitAttributeFile) + " with default values.")
			new File(rootDirectory, gitAttributeFile).withWriterAppend { w ->
				w << "#" << NELINE \
				<< "# https://help.github.com/articles/dealing-with-line-endings/" << NELINE \
				<< "#" << NELINE \
				<< "# These are explicitly windows files and should use crlf" << NELINE \
				<< NELINE \
				<< "*.bat           text eol=crlf" << NELINE \
				<< NELINE
			}
		}
	}
}
