/*
 * kubernetes-product.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * MIT License: https://mit-license.org
 */


ext.projectTypeTemplatePath='kubernetes'
if (!project.hasProperty('commonGradleBuildUrl')) {
    ext.commonGradleBuildUrl='https://raw.githubusercontent.com/toolarium/common-gradle-build/master/gradle'
}

if (!project.hasProperty('commonGradleBuildElementPath')) {
	ext.commonGradleBuildElementPath="${commonGradleBuildUrl}/build-element"
}

// in case we have no group id but have a component id, we just take over the component id
if (!project.hasProperty("projectGroupId") || "$projectGroupId".toString().trim().isEmpty() ) {
	if (project.hasProperty("projectComponentId") && !"$projectComponentId".toString().trim().isEmpty() ) {
		project.ext.set("projectGroupId", project.ext.get("projectComponentId"))
	}
}
if (!project.hasProperty("kubernetesSupport")) {
	project.ext.set("kubernetesSupport", true)
}
if (!project.hasProperty("createJar")) {
	project.ext.set("createJar", false)
}
if (!project.hasProperty("createSourceJar")) {
	project.ext.set("createSourceJar", false)
}
if (!project.hasProperty("createJavadocJar")) {
	project.ext.set("createJavadocJar", false)
}
if (!project.hasProperty("createApplicationConfigFile")) {
	project.ext.set("createApplicationConfigFile", true)
}
project.ext.set("kubernetesProjectConfiguration", false)


/***************************************************************************************
 * Dependencies
 ***************************************************************************************/
apply from: "${commonGradleBuildElementPath}/base.gradle"
apply from: "${commonGradleBuildElementPath}/base/gradle.gradle"
apply from: "${commonGradleBuildElementPath}/base/run.gradle"
apply from: "${commonGradleBuildElementPath}/base/json.gradle"
apply from: "${commonGradleBuildElementPath}/base/kubernetes.gradle"
apply from: "${commonGradleBuildElementPath}/java/repository.gradle"
apply from: "${commonGradleBuildElementPath}/java/signing.gradle"
apply from: "${commonGradleBuildElementPath}/java/publication.gradle"


/***************************************************************************************
 * artefacts
 ***************************************************************************************/
artifacts {
	archives kubernetesJar
}


/****************************************************************************************
 * Defines a kubernetes artefact
 ****************************************************************************************/
configurations {
    kubernetes
}
configurations.kubernetes {
    transitive = false
}


/****************************************************************************************
 * Create the apply config and secret install information
 ****************************************************************************************/
ext.createKubernetesApplyConfigInstallInformation = { ->

	def kubernetesInstallConfigAndSecretArtefacts = ""
	def counter = 0
	new File("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
		printInfo("> Add kubernetes dependency " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")
		
		if (counter>0) {
			kubernetesInstallConfigAndSecretArtefacts += NELINE
		}
		
		kubernetesInstallConfigAndSecretArtefacts += "${kubernetesApplyCommand} ${kubernetesApplicationConfigPath}/" + file.getName()
		counter++
	}

	// set apply config and secret for install information
	setCommonGradleProperty("kubernetesInstallConfigAndSecretArtefacts", "${kubernetesInstallConfigAndSecretArtefacts}")
}


/****************************************************************************************
 * Create a json service information file
 ****************************************************************************************/
ext.createContainerImageFileList = { fileContent ->
	def counter = 0
	def line
	def imageList = []
	def imageListContent = new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/${rootProject.name}-docker-reference.txt")
	printInfo("> Create container image reference " + colorize(HIGHLITE_LEVEL, imageListContent.getName()) + "...")
	def kubernetesInstallDockerPull = ""
	fileContent.withReader {
		while ((line = it.readLine()) != null) {
			def pos = line.indexOf("#")
			if (pos==0) {
				line = ""
			} else if (pos>0) {
				line = line.substring(pos)
			}
			
			if (!line.trim().isEmpty()) {
				pos = line.indexOf("image:")
				if (pos>=0) {
					line = line.substring(6 + pos).trim()
					
					if (!imageList.contains(line)) {
						imageList.add(line)
						imageListContent.append(line + NELINE)
						
						if (counter>0) {
							kubernetesInstallDockerPull += NELINE
						}
						kubernetesInstallDockerPull += "${dockerPullImageCommand} ${line}"
						
						logInfo("  -> Add docker image reference " + colorize(HIGHLITE_LEVEL, line) + ".")
						counter++
					} else {
						logInfo("  -> Ignore duplicate docker image reference " + colorize(HIGHLITE_LEVEL, line) + ".")
					}
				}
			}
		}
	}

	// set docker images list for install information
	setCommonGradleProperty("kubernetesInstallDockerPull", "${kubernetesInstallDockerPull}")
}


/****************************************************************************************
 * Create a json service information file
 ****************************************************************************************/
ext.createJsonServiceInfo = { urlMap, serviceMap, serviceNamespace, serviceName, servicePort, servicePathExternal, servicePathInternal, labelsList, annotationsList ->
	new File("$gradleBuildDirectory/${rootProject.name}-services/").mkdirs()
	def productInfoFile = new File("$gradleBuildDirectory/${rootProject.name}-services/${serviceName}.json")
	
	def serviceNameUsePath = serviceMap[servicePathExternal] 
	if (serviceNameUsePath == null) {
		urlMap[servicePathExternal] = serviceName
	} else {
		//printWarn("WARNING: Service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
		addError("WARNING: External service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
	}

	serviceNameUsePath = serviceMap[servicePathInternal] 
	if (serviceNameUsePath == null) {
		urlMap[servicePathInternal] = serviceName
	} else {
		//printWarn("WARNING: Service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
		addError("WARNING: Internal service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
	}
	
	productInfoFile.append(startJsonElement())
	productInfoFile.append(createJsonKeyValueElement(1, "serviceNamespace", serviceNamespace) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "serviceName", serviceName) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePort", servicePort) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePathExternal", servicePathExternal) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePathInternal", servicePathInternal) + ',' + NELINE)
	productInfoFile.append(createJsonArrayElement(1, "labels", labelsList) + ',' + NELINE)
	productInfoFile.append(createJsonArrayElement(1, "annotations", annotationsList) + NELINE)
	productInfoFile.append(endJsonElement())
}


/***************************************************************************************
 * Get kubernetes ingress
 ***************************************************************************************/
task kubernetesIngress() {
	group = 'Build'
	description = 'Creates kubernetes ingress configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupportIngressNginx') && project.getProperty('kubernetesSupportIngressNginx') }
	
	doFirst {
		printInfo("> Created kubernetes ingress configuration " + colorize(HIGHLITE_LEVEL, kubernetesIngresControlFilename) + ".")

		def hasOnlineConnection = project.hasProperty('HAS_ONLINE_CONNECTION') && project.getProperty('HAS_ONLINE_CONNECTION')
		if (hasOnlineConnection && project.hasProperty('kubernetesDownloadIngressNginxVersion') && project.getProperty('kubernetesDownloadIngressNginxVersion') && project.hasProperty('kubernetesIngressUrl')) {
			def count = downloadAndReplace("$kubernetesIngressUrl", "$kubernetesIngresControlFilename", "$kubernetesNamespace")			
		} else {
			createFileFromTemplate("$kubernetesIngresControlFilename", getTemplateFile('kubernetes-ingess-nginx.template'), true /*overwrite*/, false /*print*/)
		}
	}
}


/***************************************************************************************
 * Get kubernetes idm
 ***************************************************************************************/
task kubernetesIdm() {
	group = 'Build'
	description = 'Creates kubernetes idm configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupportIdm') && project.getProperty('kubernetesSupportIdm') }
	
	doFirst {
		def idmFile = "$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}/${rootProject.name}-kubernetes-idm.yaml"
		printInfo("> Created kubernetes idm configuration " + colorize(HIGHLITE_LEVEL, idmFile) + ".")
		createFileFromTemplate("$idmFile", getTemplateFile('kubernetes-idm.template'), true, false)
		createFileFromTemplate("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/${rootProject.name}-idm-config-kubernetes-idm.yaml", getTemplateFile('kubernetes-idm-config.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
		createFileFromTemplate("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/${rootProject.name}-idm-secret-kubernetes.yaml", getTemplateFile('kubernetes-idm-secret.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
	}
}


/***************************************************************************************
 * Get kubernetes database 
 ***************************************************************************************/
task kubernetesDatabase() {
	group = 'Build'
	description = 'Creates kubernetes database configuration'
	onlyIf { return project.hasProperty('kubernetesSupportDatabase') && project.getProperty('kubernetesSupportDatabase') }
	
	doFirst {
		def databaseFilename = "sample/${rootProject.name}-kubernetes-database.yaml"
		def databaseFile = "$kubernetesConfigurationPath/${databaseFilename}"
		printInfo("> Created kubernetes database configuration " + colorize(HIGHLITE_LEVEL, databaseFile) + ".")
		createFileFromTemplate("$databaseFile", getTemplateFile('kubernetes-database.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
		
		// set file name for install information
		setCommonGradleProperty("kubernetesInstallDatabase", "${kubernetesApplyCommand} ${databaseFilename}")
	}
}


/****************************************************************************************
 * Extract kubernetes artefacts
 ****************************************************************************************/
task extractKubernetes(type: Copy) {
	group = 'Build'
	description = 'Extract kubernetes jar file dependencoes'
    dependsOn configurations.kubernetes

    from { // use of closure defers evaluation until execution time
        configurations.kubernetes.collect { zipTree(it).matching {include "${kubernetesConfigurationPathname}/**"} }
    }

    into "$kubernetesConfigurationServicesPath"
}


/****************************************************************************************
 * Extract kubernetes artefacts
 ****************************************************************************************/
task kubernetesConcat(dependsOn: ['kubernetesIngress', 'kubernetesIdm', 'extractKubernetes', 'kubernetesDatabase']) {
	group = 'Build'
	description = 'Concat kubernetes dependencoes'	

	doLast {			
		new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/").mkdirs()
		new File("$kubernetesConfigurationElementsPath").mkdirs()

		def kubernetesServicesFilename = "$kubernetesConfigurationElementsPath/${rootProject.name}-services-kubernetes.yaml"
		createFileFromTemplate(kubernetesServicesFilename, getTemplateFile('kubernetes-ingress-controller-header.template'))
		
		// set file name for install information
		def kubernetesApplicationFilename = "${rootProject.name}-kubernetes.yaml"
		setCommonGradleProperty("kubernetesInstallApplication", "${kubernetesApplyCommand} ${kubernetesApplicationFilename}")
		
		// set uninstall information
		def kubernetesDeleteApplication = "${kubernetesDeleteCommand} namespace ${kubernetesNamespace} --namespace=${kubernetesNamespace}" + NELINE
		kubernetesDeleteApplication += "${kubernetesDeleteCommand} -A ValidatingWebhookConfiguration ingress-nginx-admission"
		setCommonGradleDefaultPropertyIfNull('kubernetesDeleteApplication', kubernetesDeleteApplication)
		
		def fileContent = new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/${kubernetesApplicationFilename}")
		def header = true
		def line
		def controllerContent = ""
		new File(kubernetesServicesFilename).withReader {
			while ((line = it.readLine()) != null) {				
				def hasComment = line.startsWith("#") || line.toString().trim().isEmpty()
				if (header && hasComment) {
					fileContent.append(line + NELINE)
				} else {
					header = false		
					controllerContent += line + NELINE
				}
			}
		}
		
		// combone ingress
		if (project.hasProperty('kubernetesIngresControlFilename') && !project.getProperty('kubernetesIngresControlFilename').toString().trim().isEmpty()) {
			header = true
			new File(kubernetesIngresControlFilename).withReader {
				while ((line = it.readLine()) != null) {				
					if (!header || !line.startsWith("#") || line.toString().trim().isEmpty()) {
						fileContent.append(line + NELINE)
						header = false		
					}
				}
			}
			fileContent.append("---" + NELINE)
		}

		// process all service definitions and select information
		def countFiles = 0
		def serviceMap=[:]
		new File("$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
			printInfo("> Add kubernetes dependency " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")

			def urlMap =  [:]
			def labelsList =  []
			def annotationsList =  []
			def serviceName = ""
			def servicePort = 0
			def servicePathExternal = ""
			def servicePathInternal = ""
			def serviceNamespace = ""
			try {			
				file.withReader {
					if (countFiles>0) {
						fileContent.append("---" + NELINE)
					}
				
					def mainSection = ""
					def kind = ""
					def annotationIndex = 0
					header = true
					fileContent.append("# Source: " + file.getName() + NELINE)
					while ((line = it.readLine()) != null) {				
						def ignoreLine = line.startsWith("#") || line.toString().trim().isEmpty()
						if (header && ignoreLine) {
						} else {
							header = false			
							line = replaceNamespace(line, "${kubernetesNamespace}")
							fileContent.append(line + NELINE)
							
							if (!line.matches("^\\s+.*")) {
								def sectionSplit = line.split(':')
								if (sectionSplit!=null && sectionSplit.length>0) {
									mainSection = sectionSplit[0]
									
									if (mainSection.equalsIgnoreCase("kind") && sectionSplit.length>1) {
										kind=sectionSplit[1].trim()
									}
								}
							}
							
							// search service path
							if (mainSection.equalsIgnoreCase("metadata")) {
								if (!line.startsWith("metadata")) {
									if (line.trim().startsWith("name:")) {
										def nameSplit = line.split(":")
										if ("Service".equalsIgnoreCase(kind) && nameSplit!=null && nameSplit.length>1) {
											serviceName = nameSplit[1].trim()
											logInfo("Found service name " + colorize(HIGHLITE_LEVEL, serviceName) + "." )
										} 
									}
									else if (line.trim().startsWith("namespace:")) {
										def namespaceSplit = line.split(":")
										if ("Service".equalsIgnoreCase(kind) && namespaceSplit!=null && namespaceSplit.length>1) {
											serviceNamespace = namespaceSplit[1].trim()
											logInfo("Found service namespace " + colorize(HIGHLITE_LEVEL, serviceNamespace) + "." )
										}
									}
									else if (annotationIndex<=0) {
										annotationIndex = line.indexOf("annotations:");
										
										if ("Deployment".equalsIgnoreCase(kind)) {
											def idx = line.indexOf('/')
											if (idx>0) {
												line = line.substring(idx + 1)
											}
											
											idx = line.indexOf(':')
											if (idx>0) {
												def key = line.substring(0, idx).replace('\"', '').trim()
												
												if (!"labels".equals(key) && !"annotations".equals(key)) {
													def value = line.substring(idx + 1).replace('\"', '').trim()
													labelsList.add('\"' + key + '\": \"' + value + '\"')
												}
											}
										}
									} else if (annotationIndex > 0 /*&& line.length() > annotationIndex && line.substring(annotationIndex).matches("^\\s+.*")*/) {
										if ("Deployment".equalsIgnoreCase(kind)) {
											def idx = line.indexOf('/')
											if (idx>0) {
												line = line.substring(idx + 1)
											}
											
											idx = line.indexOf(':')
											if (idx>0) {
												def key = line.substring(0, idx).replace('\"', '').trim()
												def value = line.substring(idx + 1).replace('\"', '').trim()
												annotationsList.add('\"' + key + '\": \"' + value + '\"')

												if (key.equals(kubernetesPathAnnotationName)) {
													servicePathExternal = value
													logInfo("Found external service path " + colorize(HIGHLITE_LEVEL, servicePathExternal) + ".")
												}
											}
										}
									} else {
										annotationIndex = 0
									}
								} else {
									annotationIndex = 0
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.trim().startsWith("port:")) {
								annotationIndex = 0
								def portSplit = line.split(":")
								if ("Service".equalsIgnoreCase(kind) && portSplit!=null && portSplit.length>1) {
									servicePort = portSplit[1].trim()
									logInfo("Found service port " + colorize(HIGHLITE_LEVEL, servicePort) + ".")
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && !line.startsWith("selector") && line.trim().indexOf("/instance:")>0) {
								annotationIndex = 0
								def selectorSplit = line.split(":")
								if ("Service".equalsIgnoreCase(kind) && selectorSplit!=null && selectorSplit.length>1) {
									servicePathInternal = selectorSplit[1].trim()
									logInfo("Found internal service path " + colorize(HIGHLITE_LEVEL, servicePathInternal) + ".")
								}
								
							} else {
								annotationIndex = 0
							}
						}
					}
					
					countFiles++
					
					if (serviceName!=null && !serviceName.trim().isEmpty() && servicePort!=null && !servicePort.trim().isEmpty()) {
						servicePathInternal = servicePathInternal + ":" + servicePort + servicePathExternal
						def servicePath = servicePathInternal
						
						if (servicePathExternal!=null && !servicePathExternal.trim().isEmpty()) {
							servicePath = servicePathExternal

							controllerContent +=  "      - path: $servicePathExternal" + NELINE
							controllerContent += "        backend:" + NELINE
							controllerContent += "          serviceName: $serviceName" + NELINE
							controllerContent += "          servicePort: $servicePort" + NELINE
						}
					
						logInfo("  -> Found service " + colorize(HIGHLITE_LEVEL, serviceName + ":" + servicePort) +  " -> " + colorize(HIGHLITE_LEVEL, servicePath) + ".")
						createJsonServiceInfo(urlMap, serviceMap, serviceNamespace, serviceName, servicePort, servicePathExternal, servicePathInternal, labelsList, annotationsList)
					} else {
						logInfo("No service found in " + colorize(HIGHLITE_LEVEL, file.getName()) + ".")
					}
				}	
			} catch (Exception e) {
				printWarn("Could not add artefact depdendency " + file.getName() + ": " + e.getMessage())
				throw e
			}			
		}	

		// append the controller content 
		fileContent.append("---" + NELINE)
		fileContent.append("# Source " + new File(kubernetesServicesFilename).getName() + NELINE)
		fileContent.append(controllerContent)

		// create a containter file list
		createContainerImageFileList(fileContent)
		
		// create the kubernetes apply config / seceret information
		createKubernetesApplyConfigInstallInformation()
		
		// create install information
		createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/INSTALL.md", getTemplateFile('INSTALL.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
	}
}

build.dependsOn kubernetesConcat
kubernetesConcat.finalizedBy kubernetesConfiguration
kubernetesJar.dependsOn kubernetesConcat

defaultTasks 'clean', 'projectValidation', 'build'


/***************************************************************************************
 * project validation
 ***************************************************************************************/
projectValidation {
	doFirst {
		if (project.getProperty('IS_NEW')) {
			new File(srcKubernetesDirectory).mkdirs()
			
			// generate git files if necessary
			if (project.hasProperty('initScmForNewProjects') && project.getProperty('initScmForNewProjects')) {
				createGitFiles(true)
			}

			registerEndMessage("" << NELINE \
								<< "  To get started, got to " + colorize(HIGHLITE_LEVEL, project.projectDir) + ":" << NELINE \
								<< "      " + colorize(HIGHLITE_LEVEL, "$startExecutable") + "" << NELINE )
		}
	}
}
