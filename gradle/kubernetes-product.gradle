/*
 * kubernetes-product.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * 
 * This file is part of the toolarium common-gradle-build.
 * 
 * The common-gradle-build is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The common-gradle-build is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar. If not, see <http://www.gnu.org/licenses/>.
 */


ext.projectTypeTemplatePath='kubernetes'
if (!project.hasProperty('commonGradleBuildUrl')) {
    ext.commonGradleBuildUrl='https://raw.githubusercontent.com/toolarium/common-gradle-build/master/gradle'
}

if (!project.hasProperty('commonGradleBuildElementPath')) {
	ext.commonGradleBuildElementPath="${commonGradleBuildUrl}/build-element"
}

// in case we have no group id but have a component id, we just take over the component id
if (!project.hasProperty("projectGroupId") || "$projectGroupId".toString().trim().isEmpty() ) {
	if (project.hasProperty("projectComponentId") && !"$projectComponentId".toString().trim().isEmpty() ) {
		project.ext.set("projectGroupId", project.ext.get("projectComponentId"))
	}
}
if (!project.hasProperty("kubernetesSupport")) {
	project.ext.set("kubernetesSupport", true)
}
if (!project.hasProperty("createJar")) {
	project.ext.set("createJar", false)
}
if (!project.hasProperty("createSourceJar")) {
	project.ext.set("createSourceJar", false)
}
if (!project.hasProperty("createJavadocJar")) {
	project.ext.set("createJavadocJar", false)
}
if (!project.hasProperty("createApplicationConfigFile")) {
	project.ext.set("createApplicationConfigFile", true)
}
project.ext.set("kubernetesProjectConfiguration", true)

if (!project.hasProperty('kubernetesUrlPath')) {
	ext.kubernetesUrlPath=""
}

// set docker image standards
if (!project.hasProperty("dockerImage")) {
	//project.ext.set("dockerImage", "node:alpine")
	project.ext.set("dockerImage", "nginx:alpine")
}
if (!project.hasProperty("dockerDeploymentSourcePath")) {
	project.ext.set("dockerDeploymentSourcePath", "build/${rootProject.name}-services/")
}


/***************************************************************************************
 * Dependencies
 ***************************************************************************************/
apply from: "${commonGradleBuildElementPath}/base.gradle"
apply from: "${commonGradleBuildElementPath}/base/gradle.gradle"
apply from: "${commonGradleBuildElementPath}/base/run.gradle"
apply from: "${commonGradleBuildElementPath}/base/json.gradle"
apply from: "${commonGradleBuildElementPath}/base/kubernetes.gradle"
apply from: "${commonGradleBuildElementPath}/java/repository.gradle"
apply from: "${commonGradleBuildElementPath}/java/signing.gradle"
apply from: "${commonGradleBuildElementPath}/java/publication.gradle"



/***************************************************************************************
 * artefacts
 ***************************************************************************************/
ext.kubernetesConfigurationProjctPath = "${kubernetesConfigurationServicesPath}/${kubernetesConfigurationPathname}"
artifacts {
	archives kubernetesJar
}


/****************************************************************************************
 * Defines a kubernetes artefact
 ****************************************************************************************/
configurations {
    kubernetes
}
configurations.kubernetes {
    transitive = false
}


/****************************************************************************************
 * Create the apply config and secret install information
 ****************************************************************************************/
ext.createKubernetesApplyConfigInstallInformation = { ->

	def kubernetesInstallConfigAndSecretArtefacts = ""
	def counter = 0
	new File("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
		logInfo("Add kubernetes install config and secret instruction for " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")
		
		if (counter>0) {
			kubernetesInstallConfigAndSecretArtefacts += NELINE
		}
		
		kubernetesInstallConfigAndSecretArtefacts += "${kubernetesApplyCommand} ${kubernetesApplicationConfigPath}/" + file.getName()
		counter++
	}

	// set apply config and secret for install information
	setCommonGradleProperty("kubernetesInstallConfigAndSecretArtefacts", "${kubernetesInstallConfigAndSecretArtefacts}")
}


/****************************************************************************************
 * Create a json service information file
 ****************************************************************************************/
ext.createContainerImageFileList = { fileContent ->
	def counter = 0
	def line
	def imageList = []
	def imageListContent = new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/${rootProject.name}-docker-reference.txt")
	printInfo("> Create container image reference " + colorize(HIGHLITE_LEVEL, "${imageListContent}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
	def kubernetesInstallDockerPull = ""
	fileContent.withReader {
		while ((line = it.readLine()) != null) {
			def pos = line.indexOf("#")
			if (pos==0) {
				line = ""
			} else if (pos>0) {
				line = line.substring(pos)
			}
			
			if (!line.trim().isEmpty()) {
				pos = line.indexOf("image:")
				if (pos>=0) {
					line = line.substring(6 + pos).trim()
					
					if (!imageList.contains(line)) {
						imageList.add(line)
						imageListContent.append(line + NELINE)
						
						if (counter>0) {
							kubernetesInstallDockerPull += NELINE
						}
						kubernetesInstallDockerPull += "${dockerPullImageCommand} ${line}"
						
						logInfo("  -> Add docker image reference " + colorize(HIGHLITE_LEVEL, line) + ".")
						counter++
					} else {
						logInfo("  -> Ignore duplicate docker image reference " + colorize(HIGHLITE_LEVEL, line) + ".")
					}
				}
			}
		}
	}

	// set docker images list for install information
	setCommonGradleProperty("kubernetesInstallDockerPull", "${kubernetesInstallDockerPull}")
}


/****************************************************************************************
 * Create a json service information file
 ****************************************************************************************/
ext.createProductServiceInfo = { serviceMap ->
	new File("$gradleBuildDirectory/${rootProject.name}-services/").mkdirs()

	def productServicesFilePath = new File("$gradleBuildDirectory/${rootProject.name}-services/services")
	productServicesFilePath.mkdir()
	def productServicesFile = new File("$productServicesFilePath/services.json")
	printInfo("> Create product information " + colorize(HIGHLITE_LEVEL, "${productServicesFile}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
	productServicesFile.append(startJsonElement())
	
	productServicesFile.append(createJsonKeyValueElement(1, "namespace", "$kubernetesNamespace") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "name", "${rootProject.name}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "version", "${project.version}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "organisation", "${project.ext.licenseOrganisation}") + ',' + NELINE)
	
	if (!"${project.ext.licenseText}".toString().trim().isEmpty()) {
		productServicesFile.append(createJsonKeyValueElement(1, "license", "${project.ext.licenseText}") + ',' + NELINE)
	}
	
	if (!"${project.ext.projectDescription}".toString().trim().isEmpty()) {
		productServicesFile.append(createJsonKeyValueElement(1, "description", "${project.ext.projectDescription}") + ',' + NELINE)
	}
	
	productServicesFile.append(createJsonKeyValueElement(1, "url-path", "${project.ext.kubernetesApplicationPrototcol}${project.ext.kubernetesApplicationHost}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "component", "${project.ext.projectType}") + ',' + NELINE)
	//productServicesFile.append(createJsonKeyValueElement(1, "runtime-timezone", "${project.ext.dockerTimezone}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "build-reference", "${project.ext.scmVersionNumber}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "build-timestamp", "${project.ext.BUILD_TIMESTAMP}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "created-by", "${project.ext.buildToolVersionStackMessage}") + ',' + NELINE)
	
	productServicesFile.append(startJsonElement(1, 'services', true))
	def size = serviceMap.size()
	serviceMap.eachWithIndex { key, value, i ->
		productServicesFile.append(createJsonKeyValueElement(3, "name", key))
		productServicesFile.append(',' + NELINE)
		productServicesFile.append(createJsonKeyValueElement(3, "url", value))
		productServicesFile.append(NELINE)
		if (size>(i+1)) {
			productServicesFile.append(endJsonElement(2))
			productServicesFile.append(',' + NELINE)
			productServicesFile.append(startJsonElement(2))
		}
	}
	
	productServicesFile.append(endJsonElement(1, true) + NELINE)
	productServicesFile.append(endJsonElement())
}


/****************************************************************************************
 * Create a json service information file
 ****************************************************************************************/
ext.createJsonServiceInfo = { urlMap, serviceMap, serviceNamespace, serviceName, imageName, servicePort, servicePathExternal, servicePathInternal, readinessPath, livenessPath, labelsList, annotationsList ->

	new File("$gradleBuildDirectory/${rootProject.name}-services/").mkdirs()
	def productServicesFilePath = new File("$gradleBuildDirectory/${rootProject.name}-services/services")
	productServicesFilePath.mkdir()
	def productInfoFile = new File("$productServicesFilePath/${serviceName}.json")
	def serviceNameUsePath = urlMap[servicePathExternal] 
	if (serviceNameUsePath == null) {
		urlMap[servicePathExternal] = serviceName
	} else {
		//printWarn("WARNING: Service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
		addError("WARNING: External service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
	}

	serviceMap[serviceName] = servicePathExternal	
	serviceNameUsePath = urlMap[servicePathInternal] 
	if (serviceNameUsePath == null) {
		urlMap[servicePathInternal] = serviceName
	} else {
		//printWarn("WARNING: Service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
		addError("WARNING: Internal service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
	}
		
	productInfoFile.append(startJsonElement())
	productInfoFile.append(createJsonKeyValueElement(1, "serviceNamespace", serviceNamespace) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "serviceName", serviceName) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePort", servicePort) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "image", imageName) + ',' + NELINE)	
	productInfoFile.append(createJsonKeyValueElement(1, "servicePathExternal", servicePathExternal) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePathInternal", servicePathInternal) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "readinessPath", readinessPath) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "livenessPath", livenessPath) + ',' + NELINE)
	productInfoFile.append(createJsonArrayElement(1, "labels", labelsList) + ',' + NELINE)
	productInfoFile.append(createJsonArrayElement(1, "annotations", annotationsList) + NELINE)
	productInfoFile.append(endJsonElement())
}


/***************************************************************************************
 * Get kubernetes ingress
 ***************************************************************************************/
task kubernetesIngress() {
	group = 'Build'
	description = 'Creates kubernetes ingress configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupportIngressNginx') && project.getProperty('kubernetesSupportIngressNginx') }
	
	doFirst {
		printInfo("> Create kubernetes ingress configuration " + colorize(HIGHLITE_LEVEL, "${kubernetesIngresControlFilename}".replace("$gradleBuildDirectory/", "")) + ".")

		def hasOnlineConnection = project.hasProperty('HAS_ONLINE_CONNECTION') && project.getProperty('HAS_ONLINE_CONNECTION')
		if (hasOnlineConnection && project.hasProperty('kubernetesDownloadIngressNginxVersion') && project.getProperty('kubernetesDownloadIngressNginxVersion') && project.hasProperty('kubernetesIngressUrl')) {
			def count = downloadAndReplace("$kubernetesIngressUrl", "$kubernetesIngresControlFilename", "$kubernetesNamespace")			
		} else {
			createFileFromTemplate("$kubernetesIngresControlFilename", getTemplateFile('kubernetes-ingess-nginx.template'), true /*overwrite*/, false /*print*/)
		}
	}
}


/***************************************************************************************
 * Get kubernetes idm
 ***************************************************************************************/
task kubernetesIdm() {
	group = 'Build'
	description = 'Creates kubernetes idm configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupportIdm') && project.getProperty('kubernetesSupportIdm') }
	
	doFirst {
		def idmFile = "$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}/${rootProject.name}-kubernetes-idm.yaml"
		printInfo("> Create kubernetes idm configuration " + colorize(HIGHLITE_LEVEL, "${idmFile}".replace("$gradleBuildDirectory/", "")) + ".")
		createFileFromTemplate("$idmFile", getTemplateFile('kubernetes-idm.template'), true, false)
		createFileFromTemplate("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/${rootProject.name}-idm-config-kubernetes-idm.yaml", getTemplateFile('kubernetes-idm-config.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
		createFileFromTemplate("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/${rootProject.name}-idm-secret-kubernetes.yaml", getTemplateFile('kubernetes-idm-secret.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
	}
}


/***************************************************************************************
 * Get kubernetes database 
 ***************************************************************************************/
task kubernetesDatabase() {
	group = 'Build'
	description = 'Creates kubernetes database configuration'
	onlyIf { return project.hasProperty('kubernetesSupportDatabase') && project.getProperty('kubernetesSupportDatabase') }
	
	doFirst {
		def databaseFilename = "sample/${rootProject.name}-kubernetes-database.yaml"
		def databaseFile = "$kubernetesConfigurationPath/${databaseFilename}"
		printInfo("> Create kubernetes database configuration " + colorize(HIGHLITE_LEVEL, "${databaseFile}".replace("$gradleBuildDirectory/", "")) + ".")
		createFileFromTemplate("$databaseFile", getTemplateFile('kubernetes-database.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
		
		// set file name for install information
		setCommonGradleProperty("kubernetesInstallDatabase", "${kubernetesApplyCommand} ${databaseFilename}")
	}
}


/****************************************************************************************
 * Extract kubernetes artefacts
 ****************************************************************************************/
task extractKubernetes(type: Copy) {
	group = 'Build'
	description = 'Extract kubernetes jar file dependencoes'
    dependsOn configurations.kubernetes

    from { // use of closure defers evaluation until execution time
        configurations.kubernetes.collect { zipTree(it).matching {include "${kubernetesConfigurationPathname}/**"} }
    }

    into "$kubernetesConfigurationServicesPath"
}



/****************************************************************************************
 * Yaml file filter
 ****************************************************************************************/
ext.yamlIndentFiler = { LineNumberReader it, indentLevel ->
	def result = []
	def numberOfLines = 0
	
	it.mark(0)
	def nextLine = ''
	while ((nextLine = it.readLine()) != null) {
		if (nextLine.length() > indentLevel && nextLine[indentLevel + 1] == ' ') {
			numberOfLines++
			result.add(nextLine)
		} else {
			break;
		}
	}
	
	it.reset()
	/*
	for (int i = 0; i < numberOfLines; i++) {
		it.readLine()
	}
	*/
	return result
}


/****************************************************************************************
 * Extract kubernetes artefacts
 ****************************************************************************************/
task kubernetesConcat(dependsOn: ['kubernetesIngress', 'kubernetesIdm', 'extractKubernetes', 'kubernetesDatabase']) {
	group = 'Build'
	description = 'Concat kubernetes dependencoes'	

	doLast {			
		new File("$kubernetesConfigurationPath").mkdirs()
		new File("$kubernetesConfigurationElementsPath").mkdirs()

		def kubernetesServicesFilename = "$kubernetesConfigurationElementsPath/${rootProject.name}-services-kubernetes.yaml"
		createFileFromTemplate(kubernetesServicesFilename, getTemplateFile('kubernetes-ingress-controller-header.template'), true /*overwrite*/, false /*print*/)
		
		// set file name for install information
		def kubernetesApplicationFilename = "${rootProject.name}-kubernetes.yaml"
		setCommonGradleProperty("kubernetesApplicationFilename", "${kubernetesApplicationFilename}")
		setCommonGradleProperty("kubernetesInstallApplication", "${kubernetesApplyCommand} ${kubernetesApplicationFilename}")
		
		// set uninstall information
		def kubernetesDeleteApplication = "${kubernetesDeleteCommand} namespace ${kubernetesNamespace} --namespace=${kubernetesNamespace}" + NELINE
		kubernetesDeleteApplication += "${kubernetesDeleteCommand} -A ValidatingWebhookConfiguration ingress-nginx-admission"
		setCommonGradleDefaultPropertyIfNull('kubernetesDeleteApplication', kubernetesDeleteApplication)
		
		def fileContent = new File("${kubernetesConfigurationPath}/${kubernetesApplicationFilename}")
		printInfo("> Create kubernetes product " + colorize(HIGHLITE_LEVEL, "${fileContent}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")		
		def header = true
		def line
		def controllerContent = ""
		new File(kubernetesServicesFilename).withReader {
			while ((line = it.readLine()) != null) {				
				def hasComment = line.startsWith("#") || line.toString().trim().isEmpty()
				if (header && hasComment) {
					fileContent.append(line + NELINE)
				} else {
					header = false		
					controllerContent += line + NELINE
				}
			}
		}
		
		// combone ingress
		if (project.hasProperty('kubernetesIngresControlFilename') && !project.getProperty('kubernetesIngresControlFilename').toString().trim().isEmpty()) {
			header = true
			new File(kubernetesIngresControlFilename).withReader {
				while ((line = it.readLine()) != null) {				
					if (!header || !line.startsWith("#") || line.toString().trim().isEmpty()) {
						fileContent.append(line + NELINE)
						header = false		
					}
				}
			}
			fileContent.append("---" + NELINE)
		}

		// process all service definitions and select information
		def countFiles = 0
		def serviceMap=[:]
		new File("$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
			printInfo("  -> Add kubernetes dependency " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")

			def urlMap =  [:]
			def labelsList =  []
			def annotationsList =  []
			def serviceName = ""
			def imageName = ""
			def servicePort = 0
			def servicePathExternal = ""
			def servicePathInternal = ""
			def serviceNamespace = ""
			def readinessPath = ""
			def livenessPath = ""

			try {			
				file.withReader {
					if (countFiles>0) {
						fileContent.append("---" + NELINE)
					}
				
					def mainSection = ""
					def kind = ""
					def annotationIndex = 0
					header = true
					fileContent.append("# Source: " + file.getName() + NELINE)
					while ((line = it.readLine()) != null) {
						def ignoreLine = line.startsWith("#") || line.toString().trim().isEmpty()
						if (header && ignoreLine) {
						} else {
							header = false			
							line = replaceNamespace(line, "${kubernetesNamespace}")
							fileContent.append(line + NELINE)
							
							if (!line.matches("^\\s+.*")) {
								def sectionSplit = line.split(':')
								if (sectionSplit!=null && sectionSplit.length>0) {
									mainSection = sectionSplit[0]
									
									if (mainSection.equalsIgnoreCase("kind") && sectionSplit.length>1) {
										kind=sectionSplit[1].trim()
									}
								}
							}
							
							// search service path
							if (mainSection.equalsIgnoreCase("metadata")) {
								if (!line.startsWith("metadata")) {
									if (line.trim().startsWith("name:")) {
										def nameSplit = line.split(":")
										if ("Service".equalsIgnoreCase(kind) && nameSplit!=null && nameSplit.length>1) {
											serviceName = nameSplit[1].trim()
											logInfo("Found service name " + colorize(HIGHLITE_LEVEL, serviceName) + "." )
										} 
									}
									else if (line.trim().startsWith("namespace:")) {
										def namespaceSplit = line.split(":")
										if ("Service".equalsIgnoreCase(kind) && namespaceSplit!=null && namespaceSplit.length>1) {
											serviceNamespace = namespaceSplit[1].trim()
											logInfo("Found service namespace " + colorize(HIGHLITE_LEVEL, serviceNamespace) + "." )
										}
									}
									else if (annotationIndex<=0) {
										annotationIndex = line.indexOf("annotations:");
										
										if ("Deployment".equalsIgnoreCase(kind)) {
											def idx = line.indexOf('/')
											if (idx>0) {
												line = line.substring(idx + 1)
											}
											
											idx = line.indexOf(':')
											if (idx>0) {
												def key = line.substring(0, idx).replace('\"', '').trim()
												
												if (!"labels".equals(key) && !"annotations".equals(key)) {
													def value = line.substring(idx + 1).replace('\"', '').trim()
													labelsList.add('\"' + key + '\": \"' + value + '\"')
												}
											}
										}
									} else if (annotationIndex > 0 /*&& line.length() > annotationIndex && line.substring(annotationIndex).matches("^\\s+.*")*/) {
										if ("Deployment".equalsIgnoreCase(kind)) {
											def idx = line.indexOf('/')
											if (idx>0) {
												line = line.substring(idx + 1)
											}
											
											idx = line.indexOf(':')
											if (idx>0) {
												def key = line.substring(0, idx).replace('\"', '').trim()
												def value = line.substring(idx + 1).replace('\"', '').trim()
												annotationsList.add('\"' + key + '\": \"' + value + '\"')

												if (key.equals(kubernetesPathAnnotationName)) {
													servicePathExternal = value
													logInfo("Found external service path " + colorize(HIGHLITE_LEVEL, servicePathExternal) + ".")
												}
											}
										}
									} else {
										annotationIndex = 0
									}
								} else {
									annotationIndex = 0
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.trim().startsWith("port:")) {
								annotationIndex = 0
								def portSplit = line.split(":")
								if ("Service".equalsIgnoreCase(kind) && portSplit!=null && portSplit.length>1) {
									servicePort = portSplit[1].trim()
									logInfo("Found service port " + colorize(HIGHLITE_LEVEL, servicePort) + ".")
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && !line.startsWith("selector") && line.trim().indexOf("/instance:")>0) {
								annotationIndex = 0
								def selectorSplit = line.split(":")
								if ("Service".equalsIgnoreCase(kind) && selectorSplit!=null && selectorSplit.length>1) {
									servicePathInternal = selectorSplit[1].trim()
									logInfo("Found internal service path " + colorize(HIGHLITE_LEVEL, servicePathInternal) + ".")
								}								
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.trim().indexOf("image:")>0) {
								def pos = line.indexOf("image:")
								if (pos>=0) {
									imageName = line.substring(6 + pos).trim()
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.indexOf("readinessProbe:")>0) {
								yamlIndentFiler(it, line.indexOf("readinessProbe:")).each { jt ->
									def idx = jt.indexOf("path:")
									if ((readinessPath==null || readinessPath.toString().isEmpty()) && idx>=0) {
										readinessPath = jt.toString().substring(idx+6).replace('\"', '')
									}
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.indexOf("livenessProbe:")>0) {
								yamlIndentFiler(it, line.indexOf("livenessProbe:")).each { jt ->
									def idx = jt.indexOf("path:")
									if ((livenessPath==null || livenessPath.toString().isEmpty()) && idx>=0) {
										livenessPath = jt.toString().substring(idx+6).replace('\"', '')
									}
								}
							} else {
								annotationIndex = 0
							}
						}
					}
					
					countFiles++
					
					if (serviceName!=null && !serviceName.trim().isEmpty() && servicePort!=null && !servicePort.trim().isEmpty()) {
						servicePathInternal = servicePathInternal + ":" + servicePort + servicePathExternal
						def servicePath = servicePathInternal
						
						if (servicePathExternal!=null && !servicePathExternal.trim().isEmpty()) {
							servicePath = servicePathExternal

							controllerContent +=  "      - path: $servicePathExternal" + NELINE
							controllerContent += "        backend:" + NELINE
							controllerContent += "          serviceName: $serviceName" + NELINE
							controllerContent += "          servicePort: $servicePort" + NELINE
						}

						logInfo("  -> Found service " + colorize(HIGHLITE_LEVEL, serviceName + ":" + servicePort) +  " -> " + colorize(HIGHLITE_LEVEL, servicePath) + ".")
						createJsonServiceInfo(urlMap, serviceMap, serviceNamespace, serviceName, imageName, servicePort, servicePathExternal, servicePathInternal, readinessPath, livenessPath, labelsList, annotationsList)
					} else {
						logInfo("No service found in " + colorize(HIGHLITE_LEVEL, file.getName()) + ".")
					}
				}	
			} catch (Exception e) {
				printWarn("Could not add artefact depdendency " + file.getName() + ": " + e.getMessage())
				throw e
			}			
		}	

		if (project.hasProperty('kubernetesProductInformationSupport') && project.getProperty('kubernetesProductInformationSupport')) {
			// create product service information
			createProductServiceInfo(serviceMap)
		}

		// append the controller content 
		fileContent.append("---" + NELINE)
		fileContent.append("# Source " + new File(kubernetesServicesFilename).getName() + NELINE)
		fileContent.append(controllerContent)

		// create a containter file list
		createContainerImageFileList(fileContent)
		
		// create the kubernetes apply config / seceret information
		createKubernetesApplyConfigInstallInformation()
		
		if (project.hasProperty('kubernetesInstallSupport') && project.getProperty('kubernetesInstallSupport')) {
			// create install information
			createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/INSTALL.md", getTemplateFile('INSTALL.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
			createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.sh", getTemplateFile('install.sh.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
			createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.bat", getTemplateFile('install.bat.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)
			
			new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.sh").setExecutable(true, true);
			new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.bat").setExecutable(true, true);
		}
	}
}

build.dependsOn kubernetesConcat
kubernetesConcat.dependsOn kubernetesConfiguration
kubernetesJar.dependsOn kubernetesConcat

defaultTasks 'clean', 'projectValidation', 'build'

if (project.hasProperty('kubernetesProductInformationSupport') && project.getProperty('kubernetesProductInformationSupport')) {
	build.finalizedBy('dockerBuild')
	publish.finalizedBy('dockerPush')
}


/***************************************************************************************
 * project validation
 ***************************************************************************************/
projectValidation {
	doFirst {
		if (project.getProperty('IS_NEW')) {
			new File(srcKubernetesDirectory).mkdirs()
			
			// generate git files if necessary
			if (project.hasProperty('initScmForNewProjects') && project.getProperty('initScmForNewProjects')) {
				createGitFiles(true)
			}

			registerEndMessage("" << NELINE \
								<< "  To get started, got to " + colorize(HIGHLITE_LEVEL, project.projectDir) + ":" << NELINE \
								<< "      " + colorize(HIGHLITE_LEVEL, "$startExecutable") + "" << NELINE )
		}
	}
}


if (project.hasProperty('kubernetesProductInformationSupport') && project.getProperty('kubernetesProductInformationSupport')) {
	apply from: "${commonGradleBuildElementPath}/base/docker.gradle"
}