/*
 * kubernetes-product.gradle
 *
 * Copyright by toolarium, all rights reserved.
 * 
 * This file is part of the toolarium common-gradle-build.
 * 
 * The common-gradle-build is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The common-gradle-build is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar. If not, see <http://www.gnu.org/licenses/>.
 */
ext.projectTypeTemplatePath='kubernetes'
ext.includeApplicationInformation=false

ext.createCustomJar = false
if (project.hasProperty('createFatJar') && project.getProperty('createFatJar').toString().trim().equalsIgnoreCase("true")) {
	ext.createCustomJar = project.getProperty('createFatJar').toString().trim().equalsIgnoreCase("true");
}

if (!project.hasProperty('commonGradleBuildUrl')) {
    ext.commonGradleBuildUrl='https://raw.githubusercontent.com/toolarium/common-gradle-build/master/gradle'
}

if (!project.hasProperty('commonGradleBuildElementPath')) {
	ext.commonGradleBuildElementPath="${commonGradleBuildUrl}/build-element"
}

// in case we have no group id but have a component id, we just take over the component id
if (!project.hasProperty("projectGroupId") || "$projectGroupId".toString().trim().isEmpty() ) {
	if (project.hasProperty("projectComponentId") && !"$projectComponentId".toString().trim().isEmpty() ) {
		project.ext.set("projectGroupId", project.ext.get("projectComponentId"))
	}
}
if (!project.hasProperty("kubernetesSupport")) {
	project.ext.set("kubernetesSupport", true)
}
if (!project.hasProperty("createJar")) {
	project.ext.set("createJar", false)
}
if (!project.hasProperty("createSourceJar")) {
	project.ext.set("createSourceJar", false)
}
if (!project.hasProperty("createJavadocJar")) {
	project.ext.set("createJavadocJar", false)
}
if (!project.hasProperty("createApplicationConfigFile")) {
	project.ext.set("createApplicationConfigFile", true)
}
project.ext.set("kubernetesProjectConfiguration", true)

if (!project.hasProperty('kubernetesUrlPath')) {
	ext.kubernetesUrlPath=""
}

// set docker image standards
if (!project.hasProperty("dockerImage")) {
	//project.ext.set("dockerImage", "node:alpine")
	project.ext.set("dockerImage", "nginx:alpine")
}


/***************************************************************************************
 * Dependencies
 ***************************************************************************************/
apply from: "${commonGradleBuildElementPath}/base.gradle"
apply from: "${commonGradleBuildElementPath}/base/gradle.gradle"
apply from: "${commonGradleBuildElementPath}/base/run.gradle"
apply from: "${commonGradleBuildElementPath}/base/json.gradle"



/***************************************************************************************
 * Build kubernetes jar file
 ***************************************************************************************/
task customJar(type: Jar, dependsOn: ['kubernetesJar']) { jar ->
	group = 'Build'
    duplicatesStrategy = 'exclude' // work around, currendly don't work "$duplicatesStrategy"
	description = 'Assembles the kubernetes configuration into a jar file'
	onlyIf { return (project.hasProperty('createCustomJar') && project.getProperty('createCustomJar').toString().equalsIgnoreCase("true")) }
	
	// define proper manifest
	manifest {
		attributes 	'Specification-Title'   : rootProject.name,
					'Specification-Version' : project.version,
					'Implementation-Title'  : rootProject.name,
					'Implementation-Version': project.version + project.ext.scmVersionNumber,
					'Created-By'		   	: project.ext.buildToolVersionStackMessage,
					'Built-By'			   	: publishingUsername,
					'Build-Timestamp'	   	: BUILD_TIMESTAMP,
					'Build-OS'			   	: "${System.properties['os.name']} (${System.properties['os.version']}), ${System.properties['os.arch']}"
	}
}

apply from: "${commonGradleBuildElementPath}/base/kubernetes.gradle"
apply from: "${commonGradleBuildElementPath}/java/repository.gradle"
apply from: "${commonGradleBuildElementPath}/java/signing.gradle"
apply from: "${commonGradleBuildElementPath}/java/publication.gradle"
apply from: "${commonGradleBuildElementPath}/base/enumconfiguration.gradle"


// set product name, organisation and copy right
setCommonGradleDefaultPropertyIfNull("productName", "${rootProject.name}")
setCommonGradleDefaultPropertyIfNull("productOrganisation", "${licenseOrganisation}")
setCommonGradleDefaultPropertyIfNull("copyrightText", "© ${YEAR} ${productOrganisation} – v${version}")


/***************************************************************************************
 * artefacts
 ***************************************************************************************/
project.ext.set("dockerDeploymentSourcePath", "build/${kubernetesApplicationConfigurationInformationPathname}")
project.ext.set("kubernetesProductServicesPathname", "container")

ext.kubernetesConfigurationProjctPath = "${kubernetesConfigurationServicesPath}/${kubernetesConfigurationPathname}"
artifacts {
	archives kubernetesJar
	archives customJar
}


/****************************************************************************************
 * Defines a kubernetes artefact
 ****************************************************************************************/
configurations {
    kubernetes
}
configurations.kubernetes {
    transitive = false
}


/****************************************************************************************
 * Create the apply config and secret install information
 ****************************************************************************************/
ext.createKubernetesApplyConfigInstallInformation = { ->

	def kubernetesInstallConfigAndSecretArtefacts = "${kubernetesApplyCommand} ${kubernetesApplicationNamespaceConfigFilename}"
	new File("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
		if (!"${kubernetesApplicationNamespaceConfigFilename}".toString().endsWith(""+file.getName())) {
			logInfo("Add kubernetes install config and secret instruction for " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")
			kubernetesInstallConfigAndSecretArtefacts += NELINE
			kubernetesInstallConfigAndSecretArtefacts += "${kubernetesApplyCommand} ${kubernetesApplicationConfigPath}/" + file.getName()
		}
	}

	// set apply config and secret for install information
	setCommonGradleProperty("kubernetesInstallConfigAndSecretArtefacts", "${kubernetesInstallConfigAndSecretArtefacts}")
}


/****************************************************************************************
 * Create a conatiner image file
 ****************************************************************************************/
ext.createContainerImageFileList = { fileContent ->
	def counter = 0
	def line
	def imageList = []
	def imageListContent = new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/${rootProject.name}-docker-reference.txt")
	printInfo("> Create container image reference " + colorize(HIGHLITE_LEVEL, "${imageListContent}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
	def kubernetesInstallDockerPull = ""
	fileContent.withReader {
		while ((line = it.readLine()) != null) {
			def pos = line.indexOf("#")
			if (pos==0) {
				line = ""
			} else if (pos>0) {
				line = line.substring(pos)
			}
			
			if (!line.trim().isEmpty()) {
				pos = line.indexOf("image:")
				if (pos>=0) {
					line = line.substring(6 + pos).trim()
					
					if (!imageList.contains(line)) {
						imageList.add(line)
						imageListContent.append(line + NELINE)
						
						if (counter>0) {
							kubernetesInstallDockerPull += NELINE
						}
						kubernetesInstallDockerPull += "${dockerPullImageCommand} ${line}"
						
						logInfo("  -> Add docker image reference " + colorize(HIGHLITE_LEVEL, line) + ".")
						counter++
					} else {
						logInfo("  -> Ignore duplicate docker image reference " + colorize(HIGHLITE_LEVEL, line) + ".")
					}
				}
			}
		}
	}

	// set docker images list for install information
	setCommonGradleProperty("kubernetesInstallDockerPull", "${kubernetesInstallDockerPull}")
}


/****************************************************************************************
 * Create a service information overview
 ****************************************************************************************/
ext.createProductServiceInfo = { serviceMap ->
	new File("$kubernetesApplicationInformationPath").mkdirs()

	def productServicesFilePath = new File("$kubernetesApplicationInformationPath/" + kubernetesProductServicesPathname)
	productServicesFilePath.mkdir()
	def productServicesFile = new File("$productServicesFilePath/index.json")
	logInfo("> Create product information " + colorize(HIGHLITE_LEVEL, "${productServicesFile}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
	productServicesFile.append(startJsonElement())
	
	productServicesFile.append(createJsonKeyValueElement(1, "namespace", "$kubernetesNamespace") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "name", "${productName}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "version", "${project.version}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "organisation", "${productOrganisation}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "copyright", "$copyrightText") + ',' + NELINE)
	
	if (!"${project.ext.licenseText}".toString().trim().isEmpty()) {
		productServicesFile.append(createJsonKeyValueElement(1, "license", "${project.ext.licenseText}") + ',' + NELINE)
	}
	
	if (!"${project.ext.projectDescription}".toString().trim().isEmpty()) {
		productServicesFile.append(createJsonKeyValueElement(1, "description", "${project.ext.projectDescription}") + ',' + NELINE)
	}
	
	productServicesFile.append(createJsonKeyValueElement(1, "url-path", "${project.ext.kubernetesApplicationPrototcol}${project.ext.kubernetesApplicationHost}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "component", "${project.ext.projectType}") + ',' + NELINE)
	//productServicesFile.append(createJsonKeyValueElement(1, "runtime-timezone", "${project.ext.dockerTimezone}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "build-reference", "${project.ext.scmVersionNumber}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "build-timestamp", "${project.ext.BUILD_TIMESTAMP}") + ',' + NELINE)
	productServicesFile.append(createJsonKeyValueElement(1, "created-by", "${project.ext.buildToolVersionStackMessage}") + ',' + NELINE)
	
	productServicesFile.append(startJsonElement(1, 'containers', true))
	def size = serviceMap.size()
	serviceMap.eachWithIndex { key, value, i ->
		productServicesFile.append(createJsonKeyValueElement(3, "reference", key))
		productServicesFile.append(',' + NELINE)
		productServicesFile.append(createJsonKeyValueElement(3, "url", value))
		productServicesFile.append(NELINE)
		if (size>(i+1)) {
			productServicesFile.append(endJsonElement(2))
			productServicesFile.append(',' + NELINE)
			productServicesFile.append(startJsonElement(2))
		}
	}
	
	productServicesFile.append(endJsonElement(1, true) + NELINE)
	productServicesFile.append(endJsonElement())
}


/****************************************************************************************
 * Create a json service information file
 ****************************************************************************************/
ext.createJsonServiceInfo = { urlMap, serviceMap, serviceNamespace, serviceName, imageName, servicePort, servicePathExternal, servicePathInternal, startupPath, readinessPath, livenessPath, labelsList, annotationsList ->

	new File("$kubernetesApplicationInformationPath").mkdirs()
	def productServicesFilePath = new File("$kubernetesApplicationInformationPath/" + kubernetesProductServicesPathname)
	productServicesFilePath.mkdir()
	def productInfoFile = new File("$productServicesFilePath/${serviceName}.json")
	def serviceNameUsePath = urlMap[servicePathExternal] 
	if (serviceNameUsePath == null) {
		urlMap[servicePathExternal] = serviceName
	} else {
		//printWarn("WARNING: Service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
		addError("WARNING: External service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
	}

	serviceMap[serviceName] = servicePathExternal
	serviceNameUsePath = urlMap[servicePathInternal] 
	if (serviceNameUsePath == null) {
		urlMap[servicePathInternal] = serviceName
	} else {
		//printWarn("WARNING: Service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
		addError("WARNING: Internal service url path conflict with services ${serviceNameUsePath} and ${serviceName}!")
	}
		
	productInfoFile.append(startJsonElement())
	productInfoFile.append(createJsonKeyValueElement(1, "serviceNamespace", serviceNamespace) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "serviceName", serviceName) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePort", servicePort) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "image", imageName) + ',' + NELINE)	
	productInfoFile.append(createJsonKeyValueElement(1, "servicePathExternal", servicePathExternal) + ',' + NELINE)
	productInfoFile.append(createJsonKeyValueElement(1, "servicePathInternal", servicePathInternal) + ',' + NELINE)

	if (startupPath!=null && !startupPath.toString().isEmpty()) {
		productInfoFile.append(createJsonKeyValueElement(1, "startupPath", startupPath) + ',' + NELINE)
	}
	
	if (readinessPath!=null && !readinessPath.toString().isEmpty()) {
		productInfoFile.append(createJsonKeyValueElement(1, "readinessPath", readinessPath) + ',' + NELINE)
	}
	
	if (livenessPath!=null && !livenessPath.toString().isEmpty()) {
		productInfoFile.append(createJsonKeyValueElement(1, "livenessPath", livenessPath) + ',' + NELINE)
	}
	
	productInfoFile.append(createJsonArrayElement(1, "labels", labelsList) + ',' + NELINE)
	productInfoFile.append(createJsonArrayElement(1, "annotations", annotationsList) + NELINE)
	productInfoFile.append(endJsonElement())
}


/****************************************************************************************
 * Create the application information overview
 ****************************************************************************************/
ext.createApplicationInformationIndex = { ->
	new File("$kubernetesApplicationInformationPath").mkdirs()

	def applicationInformationFilePath = new File("$kubernetesApplicationInformationPath")
	applicationInformationFilePath.mkdir()
	def applicationInformationIndexFile = new File("$applicationInformationFilePath/index.json")
	logInfo("> Create application information index...")
	applicationInformationIndexFile.append(startJsonElement())
	applicationInformationIndexFile.append(startJsonElement(1, 'application-information', true))
	
	applicationInformationIndexFile.append(createJsonKeyValueElement(3, "reference", kubernetesProductServicesPathname))
	applicationInformationIndexFile.append(NELINE)
	
	if (new File(kubernetesEnumConfigurationPath).exists()) {
	applicationInformationIndexFile.append(endJsonElement(2))
		applicationInformationIndexFile.append(',' + NELINE)
		applicationInformationIndexFile.append(startJsonElement(2))
		applicationInformationIndexFile.append(createJsonKeyValueElement(3, "reference", kubernetesEnumConfigurationPathname))
		applicationInformationIndexFile.append(NELINE)
	}
	
	if (new File(kubernetesApplicationServicePath).exists()) {
		applicationInformationIndexFile.append(endJsonElement(2))
		applicationInformationIndexFile.append(',' + NELINE)
		applicationInformationIndexFile.append(startJsonElement(2))
		applicationInformationIndexFile.append(createJsonKeyValueElement(3, "reference", kubernetesApplicationServicePathname))
		applicationInformationIndexFile.append(NELINE)
	}
	
	applicationInformationIndexFile.append(endJsonElement(1, true) + NELINE)
	applicationInformationIndexFile.append(endJsonElement())
}


/****************************************************************************************
 * Create a service properties overview
 ****************************************************************************************/
ext.createApplicationInformationServiceIndex = { ->
	new File("$kubernetesApplicationInformationPath").mkdirs()

	def applicationInformationQuarkusFilePath = new File("$kubernetesApplicationInformationPath/quarkus")
	if(!applicationInformationQuarkusFilePath.exists() || !applicationInformationQuarkusFilePath.isDirectory()) { 
		return;
	}
	
	def applicationInformationQuarkusIndexFile = new File("$applicationInformationQuarkusFilePath/index.json")
	logInfo("> Create application information service index...")
	applicationInformationQuarkusIndexFile.append(startJsonElement())
	applicationInformationQuarkusIndexFile.append(startJsonElement(1, 'service-properties', true))
	
	def counter = 0
	new File("$applicationInformationQuarkusFilePath").eachFileRecurse (groovy.io.FileType.FILES) { file ->
		if (!file.getName().endsWith("index.json")) {
			if (counter>0) {
				applicationInformationQuarkusIndexFile.append(endJsonElement(2))
				applicationInformationQuarkusIndexFile.append(',' + NELINE)
				applicationInformationQuarkusIndexFile.append(startJsonElement(2))
			}
		
			logInfo("  -> Add property dependency " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")
			applicationInformationQuarkusIndexFile.append(createJsonKeyValueElement(3, "reference", file.getName()))
			applicationInformationQuarkusIndexFile.append(NELINE)
			counter++
		}
	}
	
	applicationInformationQuarkusIndexFile.append(endJsonElement(1, true) + NELINE)
	applicationInformationQuarkusIndexFile.append(endJsonElement())
}


/****************************************************************************************
 * Yaml ident filter
 ****************************************************************************************/
ext.yamlIndentFilter = { LineNumberReader it, indentLevel ->
	def result = []
	def numberOfLines = 0
	
	it.mark(0)
	def nextLine = ''
	while ((nextLine = it.readLine()) != null) {
		if (nextLine.length() > indentLevel && nextLine[indentLevel + 1] == ' ') {
			numberOfLines++
			result.add(nextLine)
		} else {
			break;
		}
	}
	it.reset()
	return result
}


/***************************************************************************************
 * Get kubernetes ingress
 ***************************************************************************************/
task kubernetesIngress() {
	group = 'Build'
	description = 'Creates kubernetes ingress configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupportIngressNginx') && project.getProperty('kubernetesSupportIngressNginx') }
	
	doFirst {
		printInfo("> Create kubernetes ingress configuration " + colorize(HIGHLITE_LEVEL, "${kubernetesIngresControlFilename}".replace("$gradleBuildDirectory/", "")) + ".")

		def hasOnlineConnection = project.hasProperty('HAS_ONLINE_CONNECTION') && project.getProperty('HAS_ONLINE_CONNECTION')
		if (hasOnlineConnection && project.hasProperty('kubernetesDownloadIngressNginxVersion') && project.getProperty('kubernetesDownloadIngressNginxVersion') && project.hasProperty('kubernetesIngressUrl')) {
			def count = downloadAndReplace("$kubernetesIngressUrl", "$kubernetesIngresControlFilename", "$kubernetesNamespace")			
		} else {
			createFileFromTemplate("$kubernetesIngresControlFilename", getTemplateFile('kubernetes-ingess-nginx.template'), true /*overwrite*/, false /*print*/)
		}
	}
}


/***************************************************************************************
 * Get kubernetes idm
 ***************************************************************************************/
task kubernetesIdm() {
	group = 'Build'
	description = 'Creates kubernetes idm configuration'
	dependsOn kubernetesApplicationConfig
	onlyIf { return project.hasProperty('kubernetesSupportIdm') && project.getProperty('kubernetesSupportIdm') }
	
	doFirst {
		def idmFile = "$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}/${rootProject.name}-kubernetes-idm.yaml"
		printInfo("> Create kubernetes idm configuration " + colorize(HIGHLITE_LEVEL, "${idmFile}".replace("$gradleBuildDirectory/", "")) + ".")
		createFileFromTemplate("$idmFile", getTemplateFile('kubernetes-idm.template'), true, false)
		createFileFromTemplate("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/${rootProject.name}-idm-config-kubernetes-idm.yaml", getTemplateFile('kubernetes-idm-config.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
		createFileFromTemplate("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/${rootProject.name}-idm-secret-kubernetes.yaml", getTemplateFile('kubernetes-idm-secret.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
	}
}


/***************************************************************************************
 * Get kubernetes database 
 ***************************************************************************************/
task kubernetesDatabase() {
	group = 'Build'
	description = 'Creates kubernetes database configuration'
	onlyIf { return project.hasProperty('kubernetesSupportDatabase') && project.getProperty('kubernetesSupportDatabase') }
	
	doFirst {
		def databaseFilename = "sample/${rootProject.name}-kubernetes-database.yaml"
		def databaseFile = "$kubernetesConfigurationPath/${databaseFilename}"
		printInfo("> Create kubernetes database configuration " + colorize(HIGHLITE_LEVEL, "${databaseFile}".replace("$gradleBuildDirectory/", "")) + ".")
		createFileFromTemplate("$databaseFile", getTemplateFile('kubernetes-database.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
		
		// set file name for install information
		setCommonGradleProperty("kubernetesInstallDatabase", "${kubernetesApplyCommand} ${databaseFilename}")
	}
}


/****************************************************************************************
 * Extract kubernetes artefacts
 ****************************************************************************************/
task extractKubernetes(type: Copy) {
	group = 'Build'
	description = 'Extract kubernetes jar file dependencies'
    dependsOn configurations.kubernetes

    from { // use of closure defers evaluation until execution time
        configurations.kubernetes.collect { zipTree(it).matching {include "${kubernetesConfigurationPathname}/**"} }
    }

    into "$kubernetesConfigurationServicesPath"
}


/****************************************************************************************
 * Extract service information artefacts
 ****************************************************************************************/
task extractKubernetesInformation(type: Copy) {
	group = 'Build'
	description = 'Extract kubernetes jar file dependencies'
    dependsOn configurations.kubernetes
	
    from { // use of closure defers evaluation until execution time
        configurations.kubernetes.collect { zipTree(it).matching {include "${kubernetesApplicationConfigurationInformationPathname}/**"} }
    }

    into "$gradleBuildDirectory"
}


/****************************************************************************************
 * Process kubernetes dependencies
 ****************************************************************************************/
task processKubernetesDependencies() {
	group = 'Build'
	description = 'Process the kubernetes file dependencies'
    dependsOn extractKubernetes
	
	doLast {
		def properties = null
		if (new File("${kubernetesProductEnvironmentVariableFilename}").exists()) {
			properties = readPropertiesFile("${kubernetesProductEnvironmentVariableFilename}")
		}
		
		def configMapProperties = null
		if (new File("${kubernetesProductConfigMapEnvironmentVariableFilename}").exists()) {
			configMapProperties = readPropertiesFile("${kubernetesProductConfigMapEnvironmentVariableFilename}")
		}
		
		if (properties !=null || configMapProperties != null) {
			printInfo("> Process kubernetes dependency " + colorize(HIGHLITE_LEVEL, "$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
			new File("$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
				printInfo("  -> Process kubernetes dependency " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")

				def tempFilename = getUniqueTempName("${rootProject.name}", "${project.version}-" + file.getName(), null)
				def tempFile = new File(tempFilename)
				def changedFile = false

				try {			
					file.withReader {
						def line
						def mainSection = ""
						while ((line = it.readLine()) != null) {
							tempFile.append(line + NELINE)
							
							if (!line.matches("^\\s+.*")) {
								def sectionSplit = line.split(':')
								if (sectionSplit!=null && sectionSplit.length>0) {
									mainSection = sectionSplit[0]
								}
							}
							
							if (mainSection.equalsIgnoreCase("spec") && line.startsWith("        env:")) {
								changedFile = true
								
								if (properties!=null) {
									properties.each { prop, val ->
										tempFile.append("        - name: " + prop + NELINE)
										tempFile.append("          value: \"" + val + "\"" + NELINE)
									}
								}
								
								if (configMapProperties!=null) {
									configMapProperties.each { prop, secretName ->
										tempFile.append("        - name: " + prop + NELINE)
										tempFile.append("          valueFrom:" + NELINE)
										tempFile.append("            secretKeyRef:" + NELINE)
										tempFile.append("              name: " + secretName + NELINE)
										tempFile.append("              key: " + prop + NELINE)
									}
								}
							}
						}
					}
					
					if (changedFile) {
						copyFile("$tempFilename", "" + file.getPath(), true)
					}
				} catch (Exception e) {
					printWarn("Could not process file " + file.getName() + ": " + e.getMessage())
				} finally {
					try {
						if (tempFile!=null) {
							tempFile.delete()
						}
					} catch (Exception e) {				
					}
				}
			}	
		}
		
		// replace global environment variable
		def buildId = "${project.ext.scmVersionNumber}"
		if (buildId == null || buildId.toString().isBlank()) {
			buildId = "${project.ext.majorVersionNumber}_${project.ext.minorVersionNumber}_${project.ext.revisionVersionNumber}"
		}
		replaceFile("$kubernetesConfigurationServicesPath/$kubernetesConfigurationPathname", ".yaml", "@@PRODUCT_BUILD_ID@@", "$buildId"); //.each{ printInfo("Modified service kubernetes file " + it + ".") }			
		replaceFile("$kubernetesConfigurationElementsPath/$kubernetesConfigurationPathname", ".yaml", "@@PRODUCT_BUILD_ID@@", "$buildId"); //.each{ printInfo("Modified elements kubernetes file " + it + ".") }			
	}
}


/****************************************************************************************
 * Extract kubernetes artefacts
 ****************************************************************************************/
task kubernetesConcat(dependsOn: ['kubernetesIngress', 'kubernetesIdm', 'extractKubernetes', 'extractKubernetesInformation', 'processKubernetesDependencies', 'prepareEnumConfigurationIndex', 'kubernetesDatabase']) {
	group = 'Build'
	description = 'Concat kubernetes dependencies'	

	doLast {			
		new File("$kubernetesConfigurationPath").mkdirs()
		new File("$kubernetesConfigurationElementsPath").mkdirs()
		
		if (project.hasProperty('kustomizeSupport') && project.getProperty('kustomizeSupport')) {
			new File("$gradleBuildDirectory/${kustomizeConfigurationPathname}").mkdirs()
			new File("$kustomizeConfigurationPath").mkdirs()
			new File("$kustomizeConfigurationPath/$kustomizeBaseServicesConfigurationPath").mkdirs()
			new File("$kustomizeConfigurationPath/$kustomizeBaseControllerConfigurationPath").mkdirs()			
		}

		def kustomizeResources = []
		def kubernetesServicesFilename = "$kubernetesConfigurationElementsPath/${rootProject.name}-ingress-controller-configuration-kubernetes.yaml"
		createFileFromTemplate(kubernetesServicesFilename, getTemplateFile('kubernetes-ingress-controller-header.template'), true /*overwrite*/, false /*print*/)

		// set file name for install information
		def kubernetesApplicationFilename = "${rootProject.name}-kubernetes.yaml"
		setCommonGradleProperty("kubernetesApplicationFilename", "${kubernetesApplicationFilename}")
		setCommonGradleProperty("kubernetesInstallApplication", "${kubernetesApplyCommand} ${kubernetesApplicationFilename}")
		
		// set uninstall information
		def kubernetesDeleteApplication = "${kubernetesDeleteCommand} namespace ${kubernetesNamespace} --namespace=${kubernetesNamespace}" + NELINE
		kubernetesDeleteApplication += "${kubernetesDeleteCommand} -A ValidatingWebhookConfiguration ingress-nginx-admission"
		setCommonGradleDefaultPropertyIfNull('kubernetesDeleteApplication', kubernetesDeleteApplication)

		def fileContent = new File("${kubernetesConfigurationPath}/${kubernetesApplicationFilename}")
		printInfo("> Create kubernetes product " + colorize(HIGHLITE_LEVEL, "${fileContent}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")		
		copyFile("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/" + new File(kubernetesApplicationNamespaceConfigFilename).getName(), "${kubernetesConfigurationPath}/${kubernetesApplicationFilename}");
		fileContent.append("---")

		def header = true
		def line
		def controllerContent = ""
		def controllerHeader = ""
		new File(kubernetesServicesFilename).withReader {
			while ((line = it.readLine()) != null) {				
				def hasComment = line.startsWith("#") || line.toString().trim().isEmpty()
				if (header && hasComment) {
					controllerHeader += line + NELINE
				} else {
					header = false		
					controllerContent += line + NELINE
				}
			}
		}

		// add additional content
		if (project.hasProperty('kubernetesFileAdditionalContent') && !project.getProperty('kubernetesFileAdditionalContent').toString().trim().isEmpty()) {
			def additionalContent = project.getProperty('kubernetesFileAdditionalContent').toString()
			if (!additionalContent.toString().endsWith(NELINE)) {
				additionalContent = additionalContent.toString() + NELINE
			}
			
			fileContent.append(NELINE)
			fileContent.append(additionalContent)
			fileContent.append("---")
		}
		
		// combine ingress
		if (project.hasProperty('kubernetesIngresControlFilename') && !project.getProperty('kubernetesIngresControlFilename').toString().trim().isEmpty()) {
			if (project.hasProperty('kustomizeSupport') && project.getProperty('kustomizeSupport')) {
				copyFile(kubernetesIngresControlFilename, "$kustomizeConfigurationPath/$kustomizeBaseControllerConfigurationPath/" + new File(kubernetesIngresControlFilename).getName())
				kustomizeResources.add("$kustomizeBaseControllerConfigurationPath/" + new File(kubernetesIngresControlFilename).getName())
			}
		
			header = true
			new File(kubernetesIngresControlFilename).withReader {
				while ((line = it.readLine()) != null) {				
					if (!header || !line.startsWith("#") || line.toString().trim().isBlank()) {
						fileContent.append(line + NELINE)
						header = false		
					}
				}
			}
			fileContent.append("---" + NELINE)
		}

		// process all service definitions and select information
		def countFiles = 0
		def serviceMap=[:]
		new File("$kubernetesConfigurationServicesPath/${kubernetesConfigurationPathname}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
			printInfo("  -> Add kubernetes dependency " + colorize(HIGHLITE_LEVEL, file.getName()) + "...")

			def urlMap =  [:]
			def labelsList =  []
			def annotationsList =  []
			def serviceName = ""
			def imageName = ""
			def servicePort = 0
			def servicePathExternal = ""
			def servicePathInternal = ""
			def serviceNamespace = ""
			def startupPath = ""
			def readinessPath = ""
			def livenessPath = ""

			try {			
				file.withReader {
					if (countFiles>0) {
						fileContent.append("---" + NELINE)
					}
				
					def mainSection = ""
					def kind = ""
					def annotationIndex = 0
					header = true
					fileContent.append("# Source: " + file.getName() + NELINE)
					while ((line = it.readLine()) != null) {
						def ignoreLine = line.trim().startsWith("#") || line.toString().trim().isEmpty()
						if (header && ignoreLine) {
						} else {
							header = false			
							line = replaceNamespace(line, "${kubernetesNamespace}")
							fileContent.append(line + NELINE)
							
							if (!ignoreLine && !line.matches("^\\s+.*")) {
								def sectionSplit = line.split(':')
								if (sectionSplit!=null && sectionSplit.length>0) {
									mainSection = sectionSplit[0]
									
									if (mainSection.equalsIgnoreCase("kind") && sectionSplit.length>1) {
										kind=sectionSplit[1].trim()
									}
								}
							}
							
							// search service path
							if (ignoreLine) {
							} else if (mainSection.equalsIgnoreCase("metadata")) {
								if (!line.startsWith("metadata")) {
									if (line.trim().startsWith("name:")) {
										def nameSplit = line.split(":")
										if ("Service".equalsIgnoreCase(kind) && nameSplit!=null && nameSplit.length>1) {
											serviceName = nameSplit[1].trim()
											logInfo("Found service name " + colorize(HIGHLITE_LEVEL, serviceName) + "." )
										} 
									}
									else if (line.trim().startsWith("namespace:")) {
										def namespaceSplit = line.split(":")
										if ("Service".equalsIgnoreCase(kind) && namespaceSplit!=null && namespaceSplit.length>1) {
											serviceNamespace = namespaceSplit[1].trim()
											logInfo("Found service namespace " + colorize(HIGHLITE_LEVEL, serviceNamespace) + "." )
										}
									}
									else if (annotationIndex<=0) {
										annotationIndex = line.indexOf("annotations:");
										
										if ("Deployment".equalsIgnoreCase(kind)) {
											def idx = line.indexOf('/')
											if (idx>0) {
												line = line.substring(idx + 1)
											}
											
											idx = line.indexOf(':')
											if (idx>0) {
												def key = line.substring(0, idx).replace('\"', '').trim()
												
												if (!"labels".equals(key) && !"annotations".equals(key) && !line.toString().startsWith(" ")) {
													def value = line.substring(idx + 1).replace('\"', '').trim()
													labelsList.add('\"' + key + '\": \"' + value + '\"')
												}
											}
										}
									} else if (annotationIndex > 0 /*&& line.length() > annotationIndex && line.substring(annotationIndex).matches("^\\s+.*")*/) {
										if ("Deployment".equalsIgnoreCase(kind)) {
											def idx = line.indexOf('/')
											if (idx>0) {
												line = line.substring(idx + 1)
											}
											
											idx = line.indexOf(':')
											if (idx>0) {
												def key = line.substring(0, idx).replace('\"', '').trim()
												def value = line.substring(idx + 1).replace('\"', '').trim()
												annotationsList.add('\"' + key + '\": \"' + value + '\"')

												if (key.equals(kubernetesPathAnnotationName)) {
													servicePathExternal = value
													logInfo("Found external service path " + colorize(HIGHLITE_LEVEL, servicePathExternal) + ".")
												}
											}
										}
									} else {
										annotationIndex = 0
									}
								} else {
									annotationIndex = 0
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.trim().startsWith("port:")) {
								annotationIndex = 0
								def portSplit = line.split(":")
								if ("Service".equalsIgnoreCase(kind) && portSplit!=null && portSplit.length>1) {
									servicePort = portSplit[1].trim()
									logInfo("Found service port " + colorize(HIGHLITE_LEVEL, servicePort) + ".")
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && !line.startsWith("selector") && line.trim().indexOf("/instance:")>0) {
								annotationIndex = 0
								def selectorSplit = line.split(":")
								if ("Service".equalsIgnoreCase(kind) && selectorSplit!=null && selectorSplit.length>1) {
									servicePathInternal = selectorSplit[1].trim()
									logInfo("Found internal service path " + colorize(HIGHLITE_LEVEL, servicePathInternal) + ".")
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.trim().indexOf("image:")>0) {
								def pos = line.indexOf("image:")
								if (pos>=0) {
									imageName = line.substring(6 + pos).trim()
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.indexOf("startupProbe:")>0) {
								yamlIndentFilter(it, line.indexOf("startupProbe:")).each { jt ->
									def idx = jt.indexOf("path:")
									if ((startupPath==null || startupPath.toString().isEmpty()) && idx>=0) {
										startupPath = jt.toString().substring(idx+6).replace('\"', '')
									}
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.indexOf("readinessProbe:")>0) {
								yamlIndentFilter(it, line.indexOf("readinessProbe:")).each { jt ->
									def idx = jt.indexOf("path:")
									if ((readinessPath==null || readinessPath.toString().isEmpty()) && idx>=0) {
										readinessPath = jt.toString().substring(idx+6).replace('\"', '')
									}
								}
							} else if (mainSection.equalsIgnoreCase("spec") && !line.startsWith("spec") && line.indexOf("livenessProbe:")>0) {
								yamlIndentFilter(it, line.indexOf("livenessProbe:")).each { jt ->
									def idx = jt.indexOf("path:")
									if ((livenessPath==null || livenessPath.toString().isEmpty()) && idx>=0) {
										livenessPath = jt.toString().substring(idx+6).replace('\"', '')
									}
								}
							} else {
								annotationIndex = 0
							}
						}
					}
					
					countFiles++
					
					if (serviceName!=null && !serviceName.trim().isEmpty() && servicePort!=null && !servicePort.trim().isEmpty()) {
						servicePathInternal = servicePathInternal + ":" + servicePort + servicePathExternal
						def servicePath = servicePathInternal
						
						if (servicePathExternal!=null && !servicePathExternal.trim().isEmpty()) {
							servicePath = servicePathExternal
							
							// controller content
							controllerContent += "      - path: $servicePathExternal" + NELINE
							controllerContent += "        pathType: Prefix" + NELINE
							controllerContent += "        backend:" + NELINE
							controllerContent += "          service:" + NELINE
							controllerContent += "            name: $serviceName" + NELINE
							controllerContent += "            port:" + NELINE
							controllerContent += "              number: $servicePort" + NELINE
						}

						logInfo("  -> Found service " + colorize(HIGHLITE_LEVEL, serviceName + ":" + servicePort) +  " -> " + colorize(HIGHLITE_LEVEL, servicePath) + ".")
						createJsonServiceInfo(urlMap, serviceMap, serviceNamespace, serviceName, imageName, servicePort, servicePathExternal, servicePathInternal, startupPath, readinessPath, livenessPath, labelsList, annotationsList)
					} else {
						logInfo("No service found in " + colorize(HIGHLITE_LEVEL, file.getName()) + ".")
					}
				}

				// prepare kustomize files
				if (project.hasProperty('kustomizeSupport') && project.getProperty('kustomizeSupport')) {
					def destFile = new File("$kustomizeConfigurationPath/$kustomizeBaseServicesConfigurationPath/" + file.getName())
					file.withReader {
						def serviceFileLine
						while ((serviceFileLine = it.readLine()) != null) {
							serviceFileLine = replaceNamespace(serviceFileLine, "${kubernetesNamespace}")
							destFile.append(serviceFileLine + NELINE);
						}
					}

					kustomizeResources.add("$kustomizeBaseServicesConfigurationPath/" + file.getName())
				}
			} catch (Exception e) {
				printWarn("Could not add artefact depdendency " + file.getName() + ": " + e.getMessage())
				throw e
			}			
		}	

		if (project.hasProperty('kubernetesProductInformationSupport') && project.getProperty('kubernetesProductInformationSupport')) {
			// create product service information
			createProductServiceInfo(serviceMap)
		}
	
		// create application information service index
		createApplicationInformationServiceIndex()

		// create application information index
		createApplicationInformationIndex()

		// append the controller content 
		fileContent.append("---" + NELINE)
		fileContent.append("# Source " + new File(kubernetesServicesFilename).getName() + NELINE)
		fileContent.append(controllerContent)

		// create a containter file list
		createContainerImageFileList(fileContent)
		
		// create the kubernetes apply config / seceret information
		createKubernetesApplyConfigInstallInformation()

		// modify the controlller configuration file
		new File(kubernetesServicesFilename).write(controllerHeader)
		new File(kubernetesServicesFilename).append(controllerContent)
		
		if (project.hasProperty('kustomizeSupport') && project.getProperty('kustomizeSupport')) {
			def kustomizeFile = new File("$kustomizeConfigurationPath/$kustomizeBaseKustomization")
			createFileFromTemplate(kustomizeFile.getPath(), getTemplateFile('kustomization.template'), true /*overwrite*/, true /*print*/, true /*replace*/, NELINE /*only nl*/)

			kustomizeFile.append("resources:" + NELINE)
			copyFile("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}/" + new File(kubernetesApplicationNamespaceConfigFilename).getName(), 
			         "$kustomizeConfigurationPath/$kustomizeBaseConfigConfigurationPath/" + new File(kubernetesApplicationNamespaceConfigFilename).getName());
			kustomizeFile.append("  - $kustomizeBaseConfigConfigurationPath/" + new File(kubernetesApplicationNamespaceConfigFilename).getName() + NELINE);
		
			copyFile(kubernetesServicesFilename, "$kustomizeConfigurationPath/$kustomizeBaseControllerConfigurationPath/" + new File(kubernetesServicesFilename).getName());
			kustomizeResources.add("$kustomizeBaseControllerConfigurationPath/" + new File(kubernetesServicesFilename).getName());

			new File("$kubernetesConfigurationPath/${kubernetesApplicationConfigPath}").eachFileRecurse (groovy.io.FileType.FILES) { file ->
				if (!"${kubernetesApplicationNamespaceConfigFilename}".toString().endsWith(""+file.getName())) {
					copyFile(file.getPath(), "$kustomizeConfigurationPath/$kustomizeBaseConfigConfigurationPath/" + file.getName());
					kustomizeFile.append("  - $kustomizeBaseConfigConfigurationPath/" + file.getName() + NELINE);
				}
			}

			new File("$kubernetesConfigurationElementsPath").eachFileRecurse (groovy.io.FileType.FILES) { file ->
				if (!kustomizeResources.contains("$kustomizeBaseConfigConfigurationPath/" + file.getName()) && !kustomizeResources.contains("$kustomizeBaseControllerConfigurationPath/" + file.getName())) {
					copyFile(file.getPath(), "$kustomizeConfigurationPath/$kustomizeBaseConfigConfigurationPath/" + file.getName());
					kustomizeFile.append("  - $kustomizeBaseConfigConfigurationPath/" + file.getName() + NELINE);
				}
			}
			
			kustomizeResources.each{ kustomizeFile.append("  - " + it + NELINE) };
		}

		if (project.hasProperty('kubernetesInstallSupport') && project.getProperty('kubernetesInstallSupport')) {
			// create install information
			createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/INSTALL.md", getTemplateFile('INSTALL.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
			createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.sh", getTemplateFile('install.sh.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
			createFileFromTemplate("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.bat", getTemplateFile('install.bat.template'), true /*overwrite*/, false /*print*/, true /*replace*/, NELINE /*only nl*/)
			
			new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.sh").setExecutable(true, true);
			new File("$gradleBuildDirectory/$kubernetesConfigurationPathname/install.bat").setExecutable(true, true);
		}
	}
}

build.dependsOn kubernetesConcat
kubernetesConcat.dependsOn kubernetesConfiguration
kubernetesJar.dependsOn kubernetesConcat

defaultTasks 'clean', 'projectValidation', 'build'

if (project.hasProperty('kubernetesProductInformationSupport') && project.getProperty('kubernetesProductInformationSupport')) {
	build.finalizedBy('dockerBuild')
	publish.finalizedBy('dockerPush')
}


/****************************************************************************************
 * Additional fat-jar
 ****************************************************************************************/
 // default classifier name
def fatJarClassifierContext = ""
if (project.hasProperty("fatJarClassifierContext") && !project.getProperty("fatJarClassifierContext").toString().isEmpty()) {
	fatJarClassifierContext = "-" + project.getProperty("fatJarClassifierContext")
}

configurations {
	jar {
/*  
		withDependencies { DependencySet dependencies ->
			printInfo dependencies
		}
*/		
	}
}
configurations.jar {
	transitive = false
	
	attributes {
		attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_API))
	}
}
build { ->
	doLast {
		def fatJarFilename = "${gradleBuildDirectory}/libs/${project.name}-${project.version}.jar"
		if (project.hasProperty('createFatJar') && project.getProperty('createFatJar').toString().trim().equalsIgnoreCase("true")) {
			printInfo("> Create java fat-jar " + colorize(HIGHLITE_LEVEL, "${fatJarFilename}".replace('\\', '/').replace("$gradleBuildDirectory/", "")) + "...")
			setCommonGradleDefaultPropertyIfNull('jarRunnerFile', "${project.name}-${project.version}${fatJarClassifierContext}.jar");
			def javaAppPath = "${gradleBuildDirectory}/app"
			mkdir "$javaAppPath"
			mkdir "$javaAppPath/lib"
			def hasRunner = false
			def counter = 0
			configurations.jar.collect { 
				if ("$jarRunnerFile".toString().isEmpty() || !it.getName().toString().startsWith("$jarRunnerFile".toString())) {
				    printInfo("  -> Add fat-jar lib dependency " + colorize(HIGHLITE_LEVEL, it.getName()) + "...")
					copyFile(""+it, "$javaAppPath/lib/" + it.getName(), true) 
					counter++
				} else {
				    printInfo("  -> Set fat-jar runner dependency " + colorize(HIGHLITE_LEVEL, it.getName()) + "...")
					copyFile(""+it, "${gradleBuildDirectory}/${project.name}-${project.version}.jar", true)
					hasRunner = true
				}
			}
			
			if (new File("${srcMainResourcesDirectory}").exists()) {
				copy { from "${srcMainResourcesDirectory}" into "${javaAppPath}" } 
			}
			
			if (!hasRunner) {
				addError("No fat-jar runner found, expected ${jarRunnerFile}!")
			} else if (counter==0) {
				addError("No jar dependency found!")
			}

			buildFatJar("${javaAppPath}", "${gradleBuildDirectory}/${project.name}-${project.version}${fatJarClassifierContext}.jar", "$fatJarFilename", hasRunner)
		} else {
			delete fatJarFilename
		}		
	}
}
customJar.mustRunAfter("kubernetesJar")


/***************************************************************************************
 * project validation
 ***************************************************************************************/
projectValidation {
	doFirst {
		if (project.getProperty('IS_NEW')) {
			new File(srcKubernetesDirectory).mkdirs()
			
			// generate git files if necessary
			if (project.hasProperty('initScmForNewProjects') && project.getProperty('initScmForNewProjects')) {
				createGitFiles(true)
			}

			registerEndMessage("" << NELINE \
								<< "  To get started, got to " + colorize(HIGHLITE_LEVEL, project.projectDir) + ":" << NELINE \
								<< "      " + colorize(HIGHLITE_LEVEL, "$startExecutable") + "" << NELINE )
		}
	}
}


if (project.hasProperty('kubernetesProductInformationSupport') && project.getProperty('kubernetesProductInformationSupport')) {
	apply from: "${commonGradleBuildElementPath}/base/docker.gradle"
}